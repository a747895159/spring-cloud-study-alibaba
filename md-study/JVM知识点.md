

# 1.G1 垃圾回收器介绍

G1开创的基于Region的堆内存布局。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region）,每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。
每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB~32MB，且应为2的N次幂。
G1 设计的目标：它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量

![](https://img2020.cnblogs.com/blog/1694759/202112/1694759-20211209153745319-449859370.png)

![](https://img-blog.csdnimg.cn/8df1f910ae154866a6fb53b26f018ccc.png)

|垃圾收集器|特点|算法|适用场景|优点|缺点|
|---|---|---|---|---|---|
|Serial|最基本、历史最悠久的单线程垃圾收集器。|新生代采用标记-复制算法，老年代采用标记-整理算法。|运行在 Client 模式下的虚拟机|简单、高效|垃圾回收时必须暂停其他所有的工作线程|
|ParNew|Serial 收集器的多线程版本|新生代采用标记-复制算法，老年代采用标记-整理算法|运行在Server 模式下的虚拟机|并行，效率高||
|Parallel Scavenge|使用标记-复制算法的多线程收集器，关注吞吐量|新生代采用标记-复制算法，老年代采用标记-整理算法.|JDK1.8 默认收集器在注重吞吐量及CPU资源的场合|吞吐量高||
|SerialOld|Serial 收集器的老年代版本|标记-整理算法|在JDK<1.5与 Parallel Scavenge收集器搭配使用作为CMS收集器的后备方案|简单、高效|垃圾回收时必须暂停其他所有的工作线程|
|Parallel Old|Parallel Scavenge收集器的老年代|标记-整理算法|在注重吞吐量及CPU资源的场合|吞吐量高||
|CMS|多线程的垃圾收集器（*用户线程和垃圾回收线程可以同时进行*）|标记-清除算法|希望系统停顿时间最短，注重服务的响应速度的场景|并发收集、低停顿|对CPU资源敏感，无法处理浮动垃圾，产生垃圾碎片|
|G1|一款面向服务器的垃圾收集器，并行并发，空间整合，可预测的停顿时间|标记-复制算法|服务端应用、针对具有大内存多处理器的机器|停顿时间可控、基本无空间碎片|可能存在空间浪费、程序运行时的额外执行负载高|

- G1中五种不同类型的Region：
    + Eden regions(年轻代-Eden区)
    + Survivor regions(年轻代-Survivor区)
    + Old regions（老年代）
    + Humongous regions（巨型对象区域，通常也被认为是老年代的一部分）. G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。
    + Free resgions（未分配区域，也会叫做可用分区）- 上图中空白的区域

- GC类型: 
    + **YoungGC** （回收Eden区和Survivor区的内存）：
    + **MixedGC**（包含所有年轻代以及部分老年代Region）： 如果老年代占据了堆内存的 45% (-XX：InitiatingHeapoccupancyPercent 默认值 45%)的Region,此时就会触发 新生代+老年代+大对象 一起回收的混合回收。
    + **FullGC**（全堆扫描）：

- **记忆集（Remenbered Set,简称RSet）和卡表（Card Table）** ：
RSet全称是Remember Set，每个Region中都有一个RSet，记录的是其他Region中的对象引用本Region对象的关系(谁引用了我的对象)。
G1里面还有另外一种数据结构就Collection Set(CSet)，CSet记录的是GC要收集的Region的集合，CSet里的Region可以是任意代的。在GC的时候，对于old->young和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。
RSet存在的意义就是避免对象跨代引用时对整个堆内存对象的扫描，起到一种类似索引（更像空间索引）的作用

- 原始快照（Snapshot At The Beginning，SATB）
简洁地来说，SATB是维持并发GC的一种手段，因为像CMS、G1等收集器，首先经过初始标记，然后进行并发标记，并发标记过程中，可能对初始标记的结果产生了改动，需要进行修正，分别有增量更新和原始快照两种解决方法。CMS收集器使用增量更新来纠正对象引用关系，而G1收集器使用原始快照的策略。原始快照方式速度高于增量更新方式。	

- G1垃圾回收4个阶段:
	- **初始标记**: 仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用地Region中分配新对象。这个阶段需要停顿线程（会产生**STW**），而且是借用进行Minor GC地时候同步完成的，所以G1收集器在这个阶段没有产生特别明显的停顿。
	- **并发标记**：从GC Root开始对堆中对象进行可达性分析，结合RSet，递归扫描堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可与用户程序并发执行。当对象扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
	- **最终标记（重新标记）**: 对用户线程做另一个短暂的暂停（会产生**STW**），用于处理并发阶段结束后仍遗留下来的最后少量的SATB记录。
	- **混合回收**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程 **STW**，由多条收集器线程并行完成的。

- GCRoots
    + 虚拟机栈（栈帧中的本地变量表）中引用的对象
    + 方法区中类静态属性引用的对象
    + 方法区中常量引用的对象
    + 本地方法栈中JNI（即一般说的native方法）中引用的对象
    + 所有被同步锁（synchronized）持有的对象

# 2. 什么是JVM预热
一般情况下，在 Java 服务刚刚启动，处理的第一个请求很慢，延迟时间会达到几百毫秒，甚至有可能达到 2 秒。
OpenJDK 使用了 **JIT(Just-in-time) 即时编译技术**，可以动态的把 Java 字节码编译成高度优化过机器码，提高执行效率，但是，在编译之前，**Java 代码是以相对低效的解释器模式执行的**。



