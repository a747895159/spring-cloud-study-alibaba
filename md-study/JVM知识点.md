# 1. JVM内存模型

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240529154017429-1849821761.png)
![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240529155829304-1414438778.png)
![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240529155908483-84010171.png)

-虚拟机栈：线程私有的栈空间，存放局部变量表、操作数栈、方法执行时的各种信息。

- 字符串常量池还在堆中
- **元空间-方法区常量池（运行时常量池）**
  - 字面量:开发人员的定义的字面量，如声明为final的常量值（整数、浮点数、布尔等）、字符串字面量引用。
  - 符号引用量：所有的类和接口全限定名、字段引用(名称、描述符)、方法引用(名称、描述符、句柄、类型)

# 2. G1垃圾回收器介绍

G1开创的基于Region的堆内存布局。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region）,每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。动态地调整新生代或老年代区域大小。
每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB~32MB，且应为2的N次幂。
G1 设计的目标：它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量。

![](https://img2020.cnblogs.com/blog/1694759/202112/1694759-20211209153745319-449859370.png)

![](https://img-blog.csdnimg.cn/8df1f910ae154866a6fb53b26f018ccc.png)

| 垃圾收集器        | 特点                                                         | 算法                                               | 适用场景                                                     | 优点                                   | 缺点                                                  |
| ----------------- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ | -------------------------------------- |-----------------------------------------------------|
| Serial            | 最基本、历史最悠久的单线程垃圾收集器。                       | 新生代采用标记-复制算法，老年代采用标记-整理算法。 | 运行在 Client 模式下的虚拟机                                 | 简单、高效                             | 垃圾回收时必须暂停其他所有的工作线程                                  |
| ParNew            | Serial 收集器的多线程版本                                    | 新生代采用标记-复制算法                            | 运行在Server 模式下的虚拟机                                  | 并行，效率高                           |                                                     |
| Parallel Scavenge | 使用标记-复制算法的多线程收集器，关注吞吐量                  | 新生代采用标记-复制算法                            | JDK1.8 默认收集器在注重吞吐量及CPU资源的场合                 | 吞吐量高                               |                                                     |
| SerialOld         | Serial 收集器的老年代版本                                    | 标记-整理算法                                      | 在JDK<1.5与 Parallel Scavenge收集器搭配使用作为CMS收集器的后备方案 | 简单、高效                             | 垃圾回收时必须暂停其他所有的工作线程                                  |
| Parallel Old      | Parallel Scavenge收集器的老年代                              | 标记-整理算法                                      | 在注重吞吐量及CPU资源的场合                                  | 吞吐量高                               |                                                     |
| CMS               | 多线程的垃圾收集器（*用户线程和垃圾回收线程可以同时进行*）   | 标记-清除算法                                      | 希望系统停顿时间最短，注重服务的响应速度的场景               | 并发收集、以最小的停顿时间为目标       | 对CPU资源敏感，无法处理浮动垃圾，产生垃圾碎片，当剩余内存无法满足时，使用serialOld进行回收 |
| G1                | 一款面向服务器的垃圾收集器，并行并发，空间整合，可预测的停顿时间 | 标记-整理                                          | 服务端应用、针对具有大内存多处理器的机器                     | 可预测与可控的停顿时间、基本无空间碎片 | 可能存在空间浪费、程序运行时的额外执行负载高,适用于内存6G以上                    |

- G1中五种不同类型的Region：
  + Eden regions(年轻代-Eden区)
  + Survivor regions(年轻代-Survivor区)
  + Old regions（老年代）
  + Humongous regions（巨型对象区域，通常也被认为是老年代的一部分）. G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。
  + Free resgions（未分配区域，也会叫做可用分区）- 上图中空白的区域

- GC类型:
  + **YoungGC（MinorGC）** （回收Eden区和Survivor区的内存）：复制算法
  + **MixedGC**（包含所有年轻代以及部分老年代Region）：只存在G1模式,如果老年代占据了堆内存的 45% (-XX：InitiatingHeapoccupancyPercent 默认值 45%)的Region,此时就会触发 新生代+老年代+大对象一起回收的混合回收。如果还无法满足新的空间时，执行一次STW式的、单线程的 FullGC。
  + **MajorGC**: 老年代回收。老年代空间不足、大对象直接进入老年代但无法容纳时。MajorGC失败并触发FullGC通常是作为异常情况处理。非G1模式下。
  + **FullGC(MajorGC)**：全堆扫描

- **记忆集（Remenbered Set,简称RSet）和卡表（Card Table）** ：
  RSet全称是Remember Set，每个Region中都有一个RSet，记录的是其他Region中的对象引用本Region对象的关系(谁引用了我的对象)。
  G1里面还有另外一种数据结构就Collection Set(CSet)，CSet记录的是GC要收集的Region的集合，CSet里的Region可以是任意代的。在GC的时候，对于old->young和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。
  RSet存在的意义就是避免对象跨代引用时对整个堆内存对象的扫描，起到一种类似索引（更像空间索引）的作用。
- 卡表主要记录了老年代对新生代的引用关系，在MinorGC时减少扫描范围。卡表是记忆集RSet的一种实现方式。

- 原始快照（Snapshot At The Beginning，SATB）

> 三色标记算法：并发标记过程中，可能对初始标记的结果产生了改动，需要进行修正的算法。对应异常变动的处理有**增量更新和原始快照SATB**。
> 原始快照方式速度高于增量更新方式。原始快照方式会产生游离的垃圾，将在下次收集。
> CMS -> 增量更新 ；   G1 -> 原始快照


- G1的YoungGC：当Eden区已满，JVM分配对象到Eden区失败时，便会触发一次STW式的年轻代收集。
  - **初始标记**：这是一个快速的STW操作，用于标记从根对象直接可达的年轻代对象；
  - **对象拷贝**：将 Eden 区与form去存活的对象将被拷贝到to区或者老年代中；
  - **更新RSet**：更新老年代对新生代的引用。
  - **适应性调整**：根据当前堆的使用情况动态调整年轻代和Survivor区的大小，以优化垃圾回收效率和满足暂停时间目标。

- G1的MixedGC混合垃圾回收(老年代占用空间超过整堆比 -XX:InitiatingHeapOccupancyPercent(默认45%)时)触发的，有4个阶段:
  - **初始标记**: 仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针(幸存区的最高地址标记)的值，让下一阶段用户线程并发运行时，能正确地在可用地Region中分配新对象。这个阶段需要停顿线程（会产生**STW**），而且是借用进行YoungGC地时候同步完成的，所以G1收集器在这个阶段没有产生特别明显的停顿。
  - **并发标记**：从GC Root开始对堆中对象进行可达性分析，结合RSet，递归扫描堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可与用户程序并发执行。当对象扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
    - 变为可回收对象至少要经过两次标记过程。第一次初始标记，第二次判断这些对象finalize()方法是否又被复活。从Java 9开始，finalize()已被标记为不鼓励使用（deprecated），并在Java 15中被标记为废弃。
  - **最终标记（重新标记）**: 对用户线程做另一个短暂的暂停（会产生**STW**），用于处理并发阶段结束后仍遗留下来的最后少量的SATB记录。
  - **混合回收**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程 **STW**，由多条收集器线程并行完成的。


- GCRoots
  + 虚拟机栈（栈帧中的本地变量表）中引用的对象
  + 方法区中类静态属性引用的对象
  + 方法区中常量引用的对象
  + 本地方法栈中JNI（即一般说的native方法）中引用的对象
  + 所有被同步锁（synchronized）持有的对象

- GC Root和Remembered Set在垃圾回收过程中各自扮演着不同的角色。GC Root是垃圾回收的起始点，用于确定哪些对象是可达的；而Remembered Set则用于记录跨代(跨Region)引用关系，帮助垃圾回收器更准确地判断哪些对象应该被回收。

# 5.什么是JVM预热,JIT介绍

一般情况下，在 Java 服务刚刚启动，处理的第一个请求很慢，延迟时间会达到几百毫秒，甚至有可能达到 2 秒。
OpenJDK 使用了 **JIT(Just-in-time) 即时编译技术**，可以动态的把 Java 字节码编译成高度优化过机器码，提高执行效率，但是，在编译之前，**Java 代码是以相对低效的解释器模式执行的**。JIT的目标是发现热点代码,“热点代码”（Hot Spot Code)编译后，放入到 Code Cache中，当JVM下次遇到相同的热点代码时，直接从 Code Cache加载机器码，跳过中间的编译环节，无需再编译。

**JIT逃逸分析**是Java虚拟机（JVM）中的一项重要技术，主要用于优化对象的内存分配和垃圾回收。**通过动态分析对象的作用域和逃逸情况**，JVM可以更精确地管理对象的生命周期，提高系统的性能和并发能力。

分析类型：

- 方法逃逸：当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其它方法中。
- 线程逃逸：这个对象甚至可能被其它线程访问到，例如赋值给类变量或可以在其它线程中访问的实例变量。

从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。通过逃逸分析，编译器会对代码进行优化。

- **同步锁消除(锁粗化)**: 通过逃逸分析，发现一个对象只能从一个线程被访问到，则访问这个对象时，可以不加同步锁。针对的是synchronized锁，而对于非内置锁，比如 Lock 显示锁、CAS乐观锁等等，则JVM并不能消除。

- **栈上分配**: 从不逃逸时。对象不分配在堆上，而是分配在栈内存上。栈上分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。

- **标量替换**: 一个对象可能不需要作为一个连续的存储空间，当一个对象没有逃逸时，会将当前对象打散成若干局部变量，并分配在虚拟机栈的局部变量表中，更好的利用栈内存和寄存器.

  ```
  private static void alloc() {
     Point point = new Point（1,2）;
     System.out.println("point.x="+point.x+"; point.y="+point.y);
  }
  class Point{
      private int x;
      private int y;
  }
  // JIT就会不会直接创建Point对象，而是直接使用两个标量int x,int y来替代Point对象
  ```

# 6. Java中的对象一定是在堆上分配的吗？

不一定。
如果满足了逃逸分析的条件，一个对象，完全可以在栈上分配。**减少堆内存的分配和GC压力。**
由于栈内存有限，所以， 如果对象符合标量替换的条件，**进一步为对象来一次化整为零的手术**


# 10. 说说Java有哪些锁？

#### 一、悲观锁和乐观锁

悲观锁：当前线程去操作数据的时候，总是认为别的线程会去修改数据，所以每次操作数据的时候都会上锁，别的线程去操作数据的时候就会阻塞，比如synchronized；

乐观锁：当前线程每次去操作数据的时候都认为别人不会修改，更新的时候会判断别人是否会去更新数据，通过版本来判断，如果数据被修改了就拒绝更新，例如cas是乐观锁，但是严格来说并不是锁，通过原子性来保证数据的同步，例如数据库的乐观锁，通过版本控制来实现，cas不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响

总结：悲观锁适合写操作多的场景，乐观锁适合读操作多的场景，乐观锁的吞吐量会比悲观锁高

#### 二、公平锁和非公平锁

公平锁：有多个线程按照申请锁的顺序来获取锁，就是说，如果一个线程组里面，能够保证每个线程都能拿到锁，例如：ReentrantLock（使用的同步队列FIFO）

非公平锁：获取锁的方式是随机的，保证不了每个线程都能拿到锁，会存在有的线程饿死，一直拿不到锁，例如：synchronized，ReentrantLock

总结：非公平锁性能高于公平锁，更能重复利用CPU的时间

#### 三、可重入锁和不可重入锁

可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不会产生死锁

不可重入锁：在当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞

总结：可重入锁能一定程度的避免死锁，例如：synchronized，ReentrantLock

#### 四、自旋

自旋：一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，任何时刻最多只能有一个执行单元获得锁

总结：不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU

#### 五、共享锁和独享锁

共享锁：也叫读锁，可以查看数据，但是不能修改和删除的一种数据锁，加锁后其他的用户可以并发读取，但不能修改、增加、删除数据，该锁可被多个线程持有，用于资源数据共享

独享锁：也叫排它锁、写锁、独占锁、独享锁，该锁每一次只能被一个线程所持有，加锁后任何线程试图再次加锁都会被阻塞，直到当前线程解锁。例如：线程A对data加上排它锁后，则其他线程不能再对data加任何类型的锁，获得互斥锁的线程既能读数据又能修改数据

# 11. Lock和synchronized有啥区别？

**一、作用**

`lock` 和 `synchronized` 都是 `Java` 中去用来解决线程安全问题的一个工具，是`Java`中两种用来实现线程同步的方式。

**二、来源**

`sychronized` 是 `Java` 中的一个关键字，它可以修饰方法和代码块。当一个线程访问一个对象的同步方法或同步代码块时，其他线程不能访问这个对象的其他同步方法或同步代码块。

`lock` 是 `java.util.concurrent.locks` 包里的一个接口，这个接口有很多实现类，其中就包括我们最常用的 `ReentrantLock`(可重入锁)。它提供了更多的灵活性，比如可以尝试获取锁而不会阻塞线程、可以重试获取锁的次数以及可以提供公平锁和非公平锁。

**三、锁的力度**

`sychronized` 可以通过两种方式去控制锁的力度：

1. 把 `sychronized` 关键字修饰在方法层面。
1. 修饰在代码块上。

**锁对象的不同：**

锁对象为静态对象或者是`class`对象，那这个锁属于全局锁。
锁对象为普通实例对象，那这个锁的范围取决于这个实例的生命周期。
`lock`锁的力度是通过`lock()`与`unlock()`两个方法决定的。在两个方法之间的代码能保证其线程安全。`lock`的作用域取决于`lock`实例的生命周期。

**四、灵活性**

- `lock`锁比`sychronized`的灵活性更高。`lock`可以自主的去决定什么时候加锁与释放锁。只需要调用`lock` 的`lock()`和`unlock()`这两个方法就可以。
- `ReentrantLock`支持Condition接口提供了比 synchronized 关键字更细粒度的控制，允许在多线程环境下实现更复杂的同步逻辑调用await()等待、signal()、 condition.signalAll() 来唤醒等待的线程。

```
Condition condition = lock.newCondition();
new Thread(() -> {
    lock.lock();
    try {
        System.out.println("线程一加锁成功");
        System.out.println("线程一执行await被挂起");
        condition.await();
        System.out.println("线程一被唤醒成功");
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
        System.out.println("线程一释放锁成功");
    }
}).start();

new Thread(() -> {
    lock.lock();
    try {
        System.out.println("线程二加锁成功");
        condition.signal();
        System.out.println("线程二唤醒线程一");
    } finally {
        lock.unlock();
        System.out.println("线程二释放锁成功");
    }
}).start();

```

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240530135324721-962224465.png)


- `sychronized` 由于是一个关键字，所以他无法实现非阻塞竞争锁的方法，一个线程获取锁之后，其他锁只能等待那个线程释放之后才能有获取锁的机会。

**五、公平锁与非公平锁**

**（1）公平锁** ：

**多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。**

* 优点：所有的线程都能得到资源，不会饿死。
* 缺点：吞吐量低，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大。

**（2）非公平锁** ：

**多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。**

* 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
* 缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，最终饿死。 `lock`提供了公平锁和非公平锁两种机制（默认非公平锁）。

**PS** ：`sychronized`是非公平锁。

**六、异常是否释放锁**

`synchronized`锁的释放是被动的，当`sychronized`同步代码块执行结束或者出现异常的时候才会被释放。

`lock`锁发生异常的时候，不会主动释放占有的锁，必须手动`unlock()`来释放，所以我们一般都是将同步代码块放进`try-catch`里面，`finally`中写入`unlock()`方法，避免死锁发生。

**七、判断是否能获取锁**

`synchronized`不能。

`lock`提供了非阻塞竞争锁的方法`trylock()`，返回值是`Boolean`类型。它表示的是用来尝试获取锁：成功获取则返回`true`；获取失败则返回`false`，这个方法无论如何都会立即返回。

**八、调度方式**

`synchronized`使用的是`object`对象本身的`wait`、`notify`、`notifyAll`方法.
`lock`使用的是`Condition`进行线程之间的调度,await()、signal()、 condition.signalAll().同时底层实现的是LockSupport.park()/LockSupport.unpark()的机制.

**九、是否能中断**

`synchronized`只能等待锁的释放，不能响应中断。

`lock`等待锁过程中可以用`interrupt()`来中断。

**十、性能**

如果竞争不激烈，性能差不多；竞争激烈时，`lock`的性能会更好。

`lock`锁还能使用`readwritelock`实现读写分离，提高多线程的读操作效率。

**十一、sychronized锁升级**
JDK5之后增加了自适应的CAS自旋、锁消除(JIT逃逸分析)、锁粗化(JIT逃逸分析)、偏向锁、轻量级锁等优化策略
`synchronized` 代码块是由一对 `monitorenter/monitorexit` 指令实现的。`Monitor`的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。

每个Java对象都有一个对象头**Mark Word（标记字段）**，里面包含了对象的类型、锁状态、hashcode、线程ID等信息。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240530140412709-418436488.png)


所以现在JVM提供了三种不同的锁：**偏向锁** 、**轻量级锁** 、**重量级锁** 。

**（1）偏向锁** ：

当没有竞争出现时，默认使用偏向锁。线程会利用 CAS 操作在对象头上设置线程 ID ，以表示对象偏向当前线程。偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令。

**目的** ：在很多应用场景中，大部分对象生命周期最多会被一个线程锁定，使用偏向锁可以降低无竞争时的开销。

**（2）轻量级锁** ：

`JVM`比较当前线程的 `threadID` 和 `Java` 对象头中的`threadID`是否一致，如果不一致（比如线程2要竞争锁对象），那么需要查看 `Java` 对象头中记录的线程1是否存活（偏向锁不会主动释放因此还是存储的线程1的 `threadID`）：

1. 如果没有存活，那么锁对象还是为偏向锁（对象头中的`threadID`为线程2的）；
1. 如果存活，那么撤销偏向锁，升级为轻量级锁。

当有其他线程想访问加了轻量级锁的资源时，会使用 自旋锁 优化，来进行资源访问。轻量级锁的获取及释放依赖多次 CAS 原子指令。

**目的** ：竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，开销大，如果刚刚阻塞不久这个锁就被释放了，就得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

**（3）重量级锁** ：

如果自旋失败，很大概率再进行一次自旋，如果也是失败，因此直接升级成 重量级锁 ，进行线程阻塞，减少cpu消耗。

当锁升级为重量级锁后，未抢到锁的线程都会被阻塞，进入阻塞队列。

# 12. synchronized一定会阻塞吗？

`synchronized`关键字并不一定会阻塞线程。`synchronized`关键字用于实现Java中的同步机制，它可以应用于方法或代码块。当一个线程获得了某个对象的锁时（通过`synchronized`关键字），其他线程如果想要获取该对象的锁，就会被阻塞，直到持有锁的线程释放锁。

但是，如果一个线程尝试获取一个对象的锁时，如果锁没有被其他线程持有，那么该线程会立即获得锁，而不会被阻塞。因此，`synchronized`关键字只会在获取锁时可能导致线程阻塞，而不是一定会阻塞线程。

另外需要注意的是，`synchronized`关键字还可以用于静态方法和类级别的锁定，这时锁定的是整个类而不是对象。在这种情况下，如果一个线程获取了类级别的锁，其他线程也会被阻塞，直到持有锁的线程释放锁。

总结起来，`synchronized`关键字的阻塞行为取决于锁的可用性，如果锁可用，线程会立即获取锁而不被阻塞；如果锁不可用，线程会被阻塞直到锁可用。


# 13. String str1 = new String(“Hello”); 为例来说明不同数据存放在 jvm 不同区域

String str1 是一个字符串变量，它存放在 **栈** 中，它的值是一个引用，指向字符串对象的地址。
new String(“Hello”) 是一个字符串对象，它存放在 **堆** 中，它包含了一个字符数组和一个长度属性。
“Hello” 是一个字符串常量，它存放在 **方法区** 的常量池中.

创建时常量池中没有相同字符串则2个,否则1个

```
   String s1 = "abc";//常量池中没有"abc",创建字符串常量"abc"biang放入常量池，让s1指向常量池中的"abc"
   String s2 = "abc";//常量池中已经存在"abc",直接让s2指向常量池中的"abc",s1和s2指向常量池中的同一个对象
   System.out.println(s1 == s2);//true  “==“对你是否指向同一个对象，输出true
   System.out.println(s1.equals(s2));//true  equals方法对比的是指向的对象中的字符串内容是否相同

   String s3 = new String("abc");//常量池中已经存在"abc",运行时在堆中生成一个字符串对象，s3指向堆中的对象
   String s4 =  new String("abc");//常量池中已经存在"abc",运行时在堆中新生成生成一个字符串对象，s4指向堆中的对象
   System.out.println(s3 == s4);//false  s3、s4指向对堆中不同的字符串对象
   System.out.println(s3.equals(s4));//true 指向的对象中的字符串内容相同

   System.out.println(s1 == s3);// false s1是指向字符串常量区 s3指向的是堆区
   System.out.println(s1.equals(s3));//true 指向的对象中的字符串内容相同
```

# 14.synchronized 和 volatile 的区别是什么？

- volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。

- volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。

- volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。

- volatile基于happens-before规则的保证，确保多线程环境下变量的可见性；禁止指令重排序，是线程同步的轻量级实现，不会造成线程的阻塞。synchronized 获取作用对象的锁，执行代码，阻塞其他线程。

  > happens-before规则：控制内存操作的执行顺序和数据的可见性。是一个抽象概念，**内存屏障**这是其实现之一。
  > volatile 的一个重要作用就是和 CAS 结合，保证了原子性

# 15.什么是不可变对象，它对写并发应用有什么帮助？

final修饰的类都是不可变的对象
不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变。
不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。


# 16.什么是 AQS

AbstractQueuedSynchronizer抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架。
AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），state的操作都是通过CAS来保证其并发修改的安全性。

AQS 定义两种资源共享方式：

- **Exclusive（独占）**: ReentrantLock 是独占方式;Semaphore/CountDownLatch。
- **Share（共享）**:Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock共享。

![](https://img2024.cnblogs.com/blog/1694759/202406/1694759-20240614093746248-1149925276.png)





# 30. JVM内存模型与内存结构的含义

- JMM（Java Memory Model）内存模型定义了Java程序中各种变量的访问规则，包括变量的读取、写入和同步等操作，以确保多线程程序的正确性和可靠性。主要分为两个部分：**线程工作内存**和**主内存**。
  + 线程工作内存是每个线程独有的内存区域，它包含了线程执行时所需要的所有变量和对象，以及线程执行的指令集。每个线程都有自己的工作内存，线程之间的变量不共享，因此线程之间的通信需要通过主内存来进行。
  + 主内存是所有线程共享的内存区域，包含了所有的变量和对象。当一个线程访问某个变量时，需要将变量从主内存中读取到自己的工作内存中，然后对变量进行操作。操作完成后，线程需要将变量的值写回主内存，以便其他线程看到这个变量的最新值。
  + JVM内存模型通过锁和内存屏障等机制来确保多线程程序的正确性和可靠性。锁用于同步多个线程对共享变量的访问，内存屏障用于保证变量的可见性和顺序性。在Java中，volatile关键字可以用来保证变量的可见性和顺序性，synchronized关键字可以用来保证线程的互斥和同步，而Lock接口和Atomic类可以用来实现更灵活的同步机制。

- JVM内存结构是指Java程序在运行时所使用的内存结构和组织方式。主要有 程序计数器、栈、堆、方法区、本地方法栈。

# 31. Java常见内存溢出

| 类型               | 错误描述                                                     | 原因                                                         | 解决方案                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 堆空间溢出         | java.lang.OutOfMemoryError: Java heap space                  | 代码内存泄漏                                                 | 1.解决内存泄露；<br>2.增加堆内存，调整Survivor Space区域内存 |
| 元空间(持久代)溢出 | java.lang.OutOfMemoryError: Metaspace(PermGen space)         | 大量动态反射生成的类不断被加载                               | 增加元空间内存                                               |
| 栈溢出             | java.lang.StackOverflowError                                 | Java程序运行时抛出的一个错误，表示当前线程的栈空间已经耗尽。这通常是因为递归调用过深或者局部变量太多 | 优化代码，减少递归调用和局部变量使用                         |
| 线程堆栈满         | Fatal: Stack size too small                                  | 一般JVM启动的时候，为线程分配的栈空间太小，无法满足程序运行的需求 | 增加线程栈大小,-Xss2m。                                      |
| 系统内存被占满     | java.lang.OutOfMemoryError: unable to create new native thread | 操作系统内存被使用完，没有足够的资源创建线程                 | 1.减少线程数量；<br>2.增加系统内存                           |


# 32. JDK中4中引用

Java4种引用的级别由高到低依次为：强引用 > 软引用 > 弱引用 > 虚引用

| 引用类型 | 被垃圾回收时间 | 用途           | 生存时间                             | 示例                                                      |
| -------- | -------------- | -------------- | ------------------------------------ | --------------------------------------------------------- |
| 强引用   | 从来不会       | 对象的一般状态 | JVM停止运行时终止                    | 业务代码中的引用                                          |
| 软引用   | 在内存不足时   | 对象缓存       | 内存不足时终止                       | caffeine源码中,key支持弱引用，而value则支持弱引用和软引用 |
| 弱引用   | 在垃圾回收时   | 对象缓存       | gc运行后终止                         | ThreadLocalMap源码中                                      |
| 虚引用   | 在垃圾回收时   | 堆外内存       | 利用虚引用的通知特性来管理的堆外内存 | JDK的堆外内存源码中                                       |

# 33. TLAB分配

TLAB（Thread Local Allocation Buffer，线程本地分配缓冲区）在Java中是用来提高内存分配效率和并发性能的一个关键机制。其设计初衷正是为了在多线程并发环境下减少线程间对内存分配区域的竞争，从而加速内存分配的速度。

TLAB通过在Java堆中为每个线程划分出一个私有的内存区域，使得线程在创建对象时能够在这个私有的区域中进行内存分配。由于每个线程都有自己独立的TLAB，因此多个线程可以并行地进行内存分配操作，而无需进行线程间的同步或加锁。这样就大大减少了线程间的竞争和冲突，提高了并发性能。

TLAB的使用还可以减少垃圾回收的开销。由于TLAB中的对象都是线程私有的，因此当线程结束时，其TLAB中的对象也会随之销毁，无需再进行额外的垃圾回收操作。

# 34. 什么是 ABA 问题？如何解决？

如果一个位置的值原来是 A，后来被改为 B，再后来又被改回 A，那么进行 CAS 操作的线程将无法知晓该位置的值在此期间已经被修改过。
可以使用版本号/时间戳的方式来解决 ABA 问题。
比如说，每次变量更新时，不仅更新变量的值，还更新一个版本号。CAS 操作时不仅要求值匹配，还要求版本号匹配。
Java 的 AtomicStampedReference 类就实现了这种机制，它会同时检查引用值和 stamp 是否都相等。


# 35.JVM 加载 Class 文件的原理机制

- Java 类的加载是动态的，是按需加载的。类装载方式：
  + 隐式装载：通过new方式
  + 显示装载：通过 class.forname()等方法，显式加载需要的类

![](https://img2024.cnblogs.com/blog/1694759/202406/1694759-20240613111500449-1026619880.png)

- 类加载机制:

  - 加载：将一个Class加入内存，可以是动态代理生成的类，也可是jar中的
  - 验证：验证Class字节格式，确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求。
  - 准备：为类变量分配内存并设置类变量的初始值。静态变量复制在初始化阶段，常量直接复制，全局变量直接赋值。
  - 解析：虚拟机将常量池中的符号引用替换为直接引用的过程
  - 初始化：是执行类构造器<client>方法的过程，如果一个类中没有对静态变量赋值、静态语句块，那么编译器可以不为这个类生成<client>()方法。
    - 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化
    - 通过类名获取 Class 对象，不会触发类的初始化。
    - 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化
    - 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。

- 双亲委派加载机制：

  - 类加载器进行分层。优先使用父类加载器进行加载。这种设计能够避免重复加载类、核心类被篡改等情况发生。
  - **打破双亲委派机制则不仅要继承 ClassLoader 类，还要重写 loadClass 和 findClass 方法**。

  > 服务提供者接口（SPI）机制：
  > 以JDBC为例,DriverManager是在 rt.jar中 由启动类加载器加载。 但是他的实现是采用SPI机制 在ClassPath下面。JDK引入了**线程上下文类加载器(TCCL：Thread Context ClassLoader)**,打破双亲委派模式,利用线程上下文类加载器去加载所需要的SPI代码。
  > TCCL是从JDK1.2开始引入的，可以通过 java.lang.Thread 类中的 getContextClassLoader()和 setContextClassLoader(ClassLoader cl) 方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的默认上下文类加载器是 Application ClassLoader。

  ![](https://img2024.cnblogs.com/blog/1694759/202406/1694759-20240613112533297-288050347.png)

# 36.JVM调优

### JVM调优命令 jps、jstack、jstat、jmap

- 输入jps,获得进程号。
- top -Hp pid 获取本进程中所有线程的 CPU 耗时性能
- jstack pid 命令查看当前 java 进程的线程状态，或者 jstack -l > /tmp/output.txt 把线程堆栈信息打到一个 txt 文件。
- jstat 查看Java程序运行时堆信息(新生代、老年代、GC等信息).  jstat -gc 17351 250 4 进程ID 17351 ，采样间隔250ms，采样数4
- jmap 查看堆内存状况。

>jmap -heap pid 显示Java堆详细信息：打印堆的摘要信息，包括使用的GC算法、堆配置信息和各内存区域内存使用信息.
>jmap -histo:live pid 显示堆中对象的统计信息：其中包括每个Java类、对象数量、内存大小(单位：字节)、完全限定的类名
>jmap -dump:format=b,file=heapdump.hprof pid  堆转储快照dump文件.-XX:+HeapDumpOnOutOfMemoryError 选项，则抛出 OutOfMemoryError 时，会自动执行堆转储。


### JVM调优参数

-Xms2G： 设置初始堆大小为2G。
-Xmx4G： 设置最大堆大小为4G。
-Xss1m： 每个线程的堆栈大小为1m。
-XX:MetaspaceSize： 初始的元空间大小为512M
-Xmn2g： 设置年轻代大小为 2g。
-XX:NewRatio=4: 设置年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去持久代）。
-XX:SurvivorRatio=4： 设置年轻代中 Eden 区与 Survivor 区的大小比值。设置为 4，则两个Survivor 区与一个 Eden 区的比值为 2:4，一个 Survivor 区占整个年轻代的 1/6.
-XX:+PrintGC：开启打印 gc 信息；
-XX:ParallelGCThreads=8 设置进行年轻代垃圾收集时使用的线程数为8
-XX:ConcGCThreads=8 G1并发标记周期中执行并发工作的线程数为8
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof 内存溢出错误时产生dump文件并转存位置。
-XX:InitiatingHeapOccupancyPercent=45 G1老年代占用率达到堆总容量的45%时，开始触发混合垃圾收集MixedGC
-XX:MaxGCPauseMillis=50 G1单次垃圾收集的最长时间限制为50毫秒


### JVM 调优工具

- jconsole：用于对 JVM 中的内存、线程和类等进行监控；
- jvisualvm：JDK自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。启动配置JMX参数，可以链接监控远程主机。
- arthas：阿里开源的Java诊断工具,上述在线全能分析、查看字节码信息、方法追踪。