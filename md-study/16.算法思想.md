
算法代码随想录： https://programmercarl.com/

[TOC]
----

# 1.排序算法

![](https://img2023.cnblogs.com/blog/1694759/202308/1694759-20230804103937805-1786676518.png)

# 2.双指针法（快慢指针法）

- 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。时间复杂度：O(n)，空间复杂度：O(1)
- 在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串、N数之和 等操作的面试题，都使用双指针法。

# 3.二分查找法

- 有序数组查找相关
- 时间复杂度：O(log n)、空间复杂度：O(1)

# 4.滑动窗口法

- 类似双指针法，时间复杂度：O(n)，空间复杂度：O(1)
- 求解类似最小串
-
![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240527160955779-308986157.gif)

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240527163347403-940164935.gif)

# 5.堆栈法(或者优先队列)

- 数据(括号、相邻重复数据)匹配
- 滑动窗口最大值、前K个高频元素

# 10.动态规划
**最优子结构 + 重叠子问题（大部分自底向上，小部分递归场景自顶向下）用于求解最优解**，将**中间计算结果**维护到中间表

- 再求装满背包有几种方法、组合类问题的公式的情况下，递推公式一般为：dp[j] += dp[j - nums[i]];
- 数字三角形
  使用动态规划算法求解数字三角形问题，可以去除重复路径，时间复杂度为O\(n²)，空间复杂度为O\(n²\)
- 最长公共子序列
  蛮力破解时间复杂度 O(n2ⁿ)。采用动态规划法求解最长公共子序列时需要引入一个数组C\[i,j\]用于存储序列X\(i\)和Y\(j\)的最长公共子序列的长度，算法的时间复杂度为O\(n²\)，空间复杂度为O\(n²\)
- 最大字段和
  使用动态规划求解最大子段和问题的时间复杂度为T\(n\)=O\(n\)，空间复杂度为S\(n\)=O\(n\)

- 切割钢条最大收益
  自底向上方式解法，时间复杂度为O\(n²)
  自顶向下方式递归求解法，时间复杂度为O\(2ⁿ)
- 最长递增子序列
  使用动态规划求解最长递增子序列问题的时间复杂度为T\(n\)=O\(n²\)，空间复杂度为S\(n\)=O\(n\)
- 0-1背包问题
  使用动态规划法求解0-1背包问题的时间复杂度为: T\(n\) = O\(nw)，空间复杂度为S\(n\)= O\(nw\)

  ![](https://img2023.cnblogs.com/blog/1694759/202309/1694759-20230921170557143-1915226884.png)


# 11.分治法
将大问题分解为k个规模较小的子问题，**分解+求解+合并**

- 快速排序
- 二分查找
- 归并排序
- 假币查找

# 12.贪心算法
**最优子结构+贪心选择（自顶向下），局部最优**。某种意义上的局部最优，并不能保证总能获得全局最优解，但通常能得到较好的近似最优解。

- 部分背包问题
  按照单位重量价值从高到低选取物品，部分背包问题的时间复杂度为O(nlogn)
- Dijkstra迪杰斯特拉（单源最短路径）算法
  一个按路径长度递增的次序产生最短路径的算法,时间复杂度O\(n²\)
- 最优装载问题、找零问题、删数问题、最小生成树问题
  采用重量最轻者先装的贪心选择策略，可产生最优装载问题的最优解
- Prim算法(稠密图 时间复杂度O(n²))和Kruscal算法(稀疏图 时间复杂度O(nlogn))

# 13.回溯法

**获取问题所有解、任一解，深度优先算法**

- N皇后,
  时间复杂度: O(n!),空间复杂度: O(n)
- 图的着色，时间复杂度O(mⁿ)
- 哈密尔顿（Hamilton）回路(无向连通图路径)

# 14.分支界限法

**类似回溯算法，广度优先算法**

| 方法        | 搜索策略    | 存储结点常用结构 | 结点存储特性                                           | 应用问题                |
| ----------- | ----------- | ---------------- | ------------------------------------------------------ | ----------------------- |
| 回溯法      | 深度优先    | 栈               | 结点可以多次成为扩展结点，所有可行子结点都遍历后才弹出 | 找出满足条件的所有解    |
| 分支限界 法 | 广度/LC优先 | 队列/优先队列    | 结点只能成为一次扩展结点，剪枝或扩展后立刻出队         | 找出条件下的某个/最优解 |


# 20.大文件读取排序思想
- **分割+排序**: 从头开始将大文件File的一个小部分读入内存中，将这一小部分进行排序，然后将排序后的这一小部分写入到一个独立的小文件。循环生成一堆有序小文件。
- **多路归并**：将每一个小文件FileX的第一个数取出，即每一个小文件里的最小数，对这些数进行归并排序，将这些数里的最小数字写入大文件maxFail的第一行，此即整个大文件里的最小数字。

>
> 将文件FileX最小数放入内存中，当内存中数据超过一定量时，写入有序的大文件中。
> 将文件FileX 行数指针+1，将大文件的行数指针+1。 继续前面的循环，直到所有小文件都遍历完成。
>

# 21、如何从含有100亿个整数的文件中找出其中最大的100个？

- 全部排序：将数据集全部排序，然后取出最大的100个数。
- 分治法:将大数据集分成若干个小数据集,分别找出最大的100个数，然后合并起来再找出最大的100个数。
- 堆排序算法：使用一个小根堆来存储当前已经找到的最大的k个数，然后遍历剩余的数，如果比堆顶元素大，则将堆顶元素替换为该数，然后重新调整堆。
- **快速选择算法和归并算法**: 将数据集分成两部分，然后只对包含最大的k个数的那一部分继续递归，直到找到最大的k个数。


# 22.ZAB协议选举流程

- zookeeper 采用了递增的事务id号（zxid）来标识事务，64位数字。高32位代表周期编号，低32位用于递增计数，每一次选举周期编号+1；


# 23. Raft协议选举流程
三种角色：Leader（领导者）、Follower（跟随者）、Candidate（候选人）
- Raft 使用心跳触发Leader选举。当Server启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。
- 如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。
- Follower将其当前**term(任期)**加一然后转换为Candidate,首先给自己投票并且给集群中的其他服务器发送选举RPC。结果有以下三种情况：
  - 赢得了多数（超过1/2）的选票，成功选举为Leader；
  - 收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；
  - 没有Server赢得多数的选票，Leader选举失败，等待选举时间超时（`Election Timeout`）后发起下一次选举。

