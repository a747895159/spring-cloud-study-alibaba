[TOC]
----

# 1.redis基本数据类型，应用场景？

高性能：纯内存操作、是基于非阻塞的 IO 多路复用机制、单线程反而避免了多线程的频繁上下文切换问题。

![](https://p5.toutiaoimg.com/origin/tos-cn-i-qvj2lq49k0/a0e48f0d04814c8bb8536cc93b0b0c9a?from=pc)

- **String** （字符串）：适用于存储文本、数字等数据。常见用途包括缓存、计数器、会话管理等。
- **Hash** （哈希表）：适合存储对象（如用户数据、商品信息）的多个字段及其值。能快速检索或修改字段值。
- **List** （列表）：用于保存有序的元素序列。适用于实现消息队列、栈、发布订阅等功能。
- **Set** （集合）：用于保存不重复的元素。适用于存储标签、好友列表等，也可用于计算交集、并集等操作。
- **Sorted Set** （有序集合）：类似于 Set，但每个元素都有一个分数，可用分数对元素进行排序。适用于实现排行榜、优先级队列等。
- **Bitmap** （位图）：适合存储布尔值，可用于追踪用户在线状态、用户活跃度等。能执行位运算以统计和查询状态。
- **HyperLogLog** ：用于估算集合中不重复元素的数量，适用于统计 UV（独立访客数）等场景。
- **Geospatial** （地理空间）：用于存储地理位置信息，支持距离计算和附近位置的查询。适合实现地图应用、位置服务等。
- **Pub/Sub** （发布订阅）：用于实现消息发布和订阅机制，适用于构建实时通知、事件驱动系统等。

# 2.redis三大客户端选型

- **Jedis客户端**：提供了比较全面的Redis命令的支持。
    - 缺点：阻塞的I/O，不支持异步；客户端实例线程不安全，需要通过连接池来使用。
- **Lettuce客户端**：可扩展的线程安全的Redis客户端，支持异步IO。基于Netty框架实现。支持高级Redis特性，如集群、Sentinel、管道和编码器的支持。**Spring Boot2.0 默认使用的Redis客户端是Lettuce**。
- **Redisson客户端**：是一个在 Redis 的基础上实现的 Java 驻内存数据网格。线程安全的客户端，基于Netty的非阻塞I/O，性能较高。提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列。
    - 缺点：Redisson 对字符串的操作支持比较差；不支持排序、事务、管道、分区等Redis特性。

**使用建议：lettuce + Redisson**


# 3.Redisson分布式锁简介

- Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock)、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。
- RLock结构 key就是UUID+threadId，采用**hash结构**的value就是重入值，在分布式锁时，这个值为1（Redisson还可以实现重入锁，那么这个值就取决于重入次数了）


# 4.Redis中hash与HashMap 的区别？

- 从存储结构上,redis的hash小数据量的时候采用的是 **压缩列表，大数量是采用的是哈希表**。
- 从哈希冲突来看,redis的hash采用开放地址法（线性探针法）来解决键的冲突，HashMap采用的是链地址法
  - redis设计为了不需要额外的指针,减少内存使用,当装载因子增大时，冲突增多。所以redis扩容时，采用渐进式Rehash。
  - HashMap为了均衡频繁的插入、删除、查找等操作，提供良好的性能，采用链地址法。
- 从数据结构来看，redis的hash和java的HashMap很像，**区别在于rehash**：
    - HashMap在resize时是一次性拷贝的，然后使用新的数组，多线程协同扩容，迁移过程中线程阻塞。
    - Redis是渐进式rehash，后台单线程定时进行扩容迁移，可以避免因扩容导致的线程卡顿现象。使用2个哈希表，读操作：会先去ht[0]中找，找不到再去ht[1]中找。写操作：直接写在ht[1]中。


  
# 5.Redis集群方案

Redis集群中每个redis实例（可能一台机部署多个实例）会使用两个Tcp端口，一个用于给客户端（redis-cli或应用程序等）使用的端口 6379，另一个是用于集群中实例相互通信的内部总线端口，且第二个端口比第一个端口一定大10000。集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式。


![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521171725824-105309848.png)

Redis Cluster使用Gossip协议维护节点的元数据信息，这种协议是P2P模式的，主要指责就是信息交换。 Gossip协议工作原理就是节点彼此不断通信交换信息，一种去中心化思路的分布式协议，来确保网络中所有节点的数据一样。
redis官方集群方案集群超过800左右时,集群间通信占用大量带宽，集群吞吐量下降，性能下降严重。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521152242297-550427869.png)

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521152534542-1420282275.png)


# 6.Redis持久化方案与主从同步

- AOF:先执行命令，把数据写入内存，然后才记录日志。三种写会策略：Always(同步写)、EverySec(每秒写)、NO(操作系统控制)。
- AOF重写机制：当AOF文件体积达到一定大小时，会触发重写机制，由后台线程 bgrewriteaof 来完成的，然后删除AOF文件。
- RDB：记录某一时刻的全量快照数据。bgsave命令后台子进程完成，不阻塞主线程。save命令主线程执行，会导致阻塞。
- RDB+AOF混合使用，定期全量快照数据RDB + 增量AOF。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521152458432-1912275025.png)


# 7.关于 redis，说一下 sorted set 底层原理

Redis 的 sorted set 是一种有序集合，它的底层实现是使用了 **跳表（Skip List）和哈希表（Hash Table）** 这两种数据结构。

- **跳表**是一种类似于链表的数据结构，但是它在每个节点上增加了多个指针，可以快速地跳过一些节点，从而提高了查找效率。
- **哈希表**则是一种以键值对形式存储数据的数据结构，可以快速地进行数据的插入、查找和删除操作。采用开放地址法（线性探针法）来解决键的冲突
  在 Redis 的 sorted set 中，每个元素都有一个分数（score），根据分数的大小来进行排序。使用跳跃表可以快速地进行分数的比较和排序，而使用哈希表可以快速地进行元素的查找和删除操作。同时，
- Redis 还使用了**压缩列表（Ziplist）**来优化存储空间，对于一些小的 sorted set，它们的元素可以被存储在一个压缩列表中，从而减少了内存的使用。



# 8.分布式缓存 Redis与DB数据一致性解决方案

若系统严格要求 “缓存+数据库” 必须保持一致性的话，可以使用：读请求和写请求串行化，串到一个内存队列里去，吞吐量大幅度降低。

- 缓存是通过牺牲强一致性来提高性能的,由CAP理论决定的。缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。
- 双删机制: 先删缓存、**更新数据库、再删缓存**
- Canal+RocketMQ同步MySQL，由BinLog消息统一进行删除缓存。
- 旁路缓存(Cache Aside Pattern):
  - 先读缓存，没有的话再读数据库，然后放入缓存，同时返回响应。
  - 更新的时候，先更新数据库，然后再删除缓存(懒加载思想)。


# 9.如何解决缓存热点（热key）问题？

- 本地缓存caffeine + 分布式缓存redis.以下是多级缓存注解事项：

    - 两级缓存数据一致性问题？
        + 后台保存数据后，写入Redis缓存，同时发布MQ消息。业务应用接收到消息后删除本地缓存。
        + 当流量请求到达时，业务应用若本地缓存不存在，则从 Redis 中加载缓存至本地缓存。
    - 本地缓存要解决JVM内存问题，不适合存储大量数据,需要对缓存大小进行评估。
    - 本地缓存数据应设置效期和合理的淘汰策略,建议使用caffeine,策略是LRU+LFU，既具有较好的时间局部性，又具有大部分数据场景。

  ```
  Cache<String, Map<Integer, String>> cache = Caffeine.newBuilder().expireAfterWrite(5, TimeUnit.MINUTES).maximumSize(500).build()
  
  ```

    - 考虑设置定时任务来同步缓存，以防止极端情况下数据丢失。
    - 当应用重启时，本地缓存会失效，因此需要注意加载分布式缓存的时机。
    - 当本地缓存失效时，需要使用 synchronized 进行加锁，确保由一个线程加载 Redis 缓存，避免并发更新。
    - 如果业务能够接受短时间内的数据不一致，那么本地缓存更适用于读取场景。




# 10.什么是BigKey

* 【字符串类型】： 单个 string 类型的 value 值超过 1MB，就可以认为是 Bigkey。
* 【非字符串类型】：哈希、列表、集合、有序集合等， 它们的元素个数超过 2000 个，就可以认为是 Bigkey。

存在问题：

- **侵占带宽网络拥堵**
- **数据请求大量超时**: redis是单线程的，当一个key数据响应的久一点，就会造成后续请求频繁超时
- **内存溢出或处理阻塞**：可以过大时会导致内存数据溢出；同时过期删除时，由于数据量过大，会影响主从同步。

解决方案： 将BigKey进行业务拆分，分成多个小key。



# 11.什么是HotKey

某个key频繁被访问，访问次数显著高于其他key，单点访问频率过高，占用大量资源。

存在问题：

- **分片服务瘫痪**: 同一个实例下某个key访问量很高，占用某个分片大量资源，而其他分片访问较少。

- **cpu占用高，影响其他服务**: 单个分片cpu占用率过高，其他分片无法拥有cpu资源，从而被影响

- **引发缓存击穿**: 当缓存请求不到会去请求数据库。如果请求过于集中，redis承载不了，就会有大量请求打到数据库。**此时，可能引发数据库服务瘫痪。进而引发系统雪崩** 。

解决方案： 使用本地缓存

!(https://img-blog.csdnimg.cn/20210612182456981.png)


# 12.Redis为啥设计成16384个槽

- redis节点发送心跳包时需要把所有的槽放到这个心跳包里，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 * 8 (8 bit) * 1024(1k) = 16K）个char，也就是说使用2k个char的空间，能表达16k的槽数。
- 虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（8 * 8 (8 bit) * 1024(1k) =65K），也就是说需要需要8k的心跳包，作者认为这样做不太值得。
- 集群节点越多，心跳包的消息体内携带的数据越多，如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。


# 13.Redis脑裂问题

Redis脑裂是指在一个Redis集群中，由于某些原因（如网络问题、配置错误等），导致集群中的多个节点无法相互通信，进而造成数据不一致和丢失的现象。脑裂现象对于Redis集群的稳定性和数据完整性构成了严重威胁。

脑裂问题的发生通常涉及以下几个方面：

- 网络问题：在网络不稳定或者分区的情况下，Redis集群中的节点之间可能无法正常通信，从而导致脑裂现象。
- 配置错误：如果Redis集群的配置不当，比如节点间的超时时间设置不合理，或者节点数量过多导致通信压力增大，都可能增加脑裂发生的风险。
- 主从切换问题：在Redis的主从复制架构中，如果主节点宕机，从节点需要通过选举来升级为新的主节点。在这个过程中，如果旧的主节点重新上线并且继续处理写请求，就会与新的主节点形成两个主节点并存的局面，导致脑裂。


# 14.redis事务与lua脚本的区别

- redis事务：基于乐观锁，多个client对操作的key进行watch，一旦有一个client进行了exec，那么其它client的exec就会失效。类似CAS操作。
    - multi(开启事务)、exec(提交事务)、discard(放弃事务)、watch(当被监控的键被修改后取消之后的事务)
  > 执行事务之前，使用WATCH命令监视一个或多个键
  > 使用MULTI命令标记事务的开始，之后的所有写命令都会被缓存起来，直到EXEC命令被执行。
  > 使用EXEC命令提交事务并执行所有缓存的命令。此时，Redis会再次检查被WATCH的键是否被修改过。如果没有被修改，事务正常执行；如果被修改过，事务将被放弃.
  > WATCH counter
  > MULTI
  > incr counter
  > EXEC

- lua脚本：基本原理为使脚本相当于一个redis命令，可以结合redis原有命令，自定义脚本逻辑。

- 相同点：很好的实现了一致性、隔离性和持久性，但都没有实现原子性,如果出现运行错误，都不支持回滚的。
- 不同点：**redis事务是一次性批量执行多条命令，lua脚本可以加入自定义逻辑**.


# 15.缓存穿透、缓存击穿、缓存雪崩、缓存预热

- 缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时查询数据库。若流量大时，数据库可能会宕机。
    - 1.布隆过滤器：将所有可能存在的key放到一个足够大bitmap中。一定不存在的数据直接被bitmap拦截掉。
    - 2.短时缓存：若数据库查询的数据为空，扔把key缓存起来，设置一个短时间的过期时间。数据插入后清理。
- 缓存击穿：某个热点key失效后, 大并发访问, 导致数据库宕机。
    - 1.加锁排队：互斥锁对某个key只允许一个线程查数据写缓存，其他线程等待。
    - 2.设置热点Key 永不过期
- 缓存雪崩：缓存时集中在某一时段同时失效，请求全部转发到数据库，数据库瞬时压力过重导致雪崩效应。
    - 1.缓存时间增加随机值：每个缓存时间不一样，避免集体失效。
- 缓存预热：系统上线前把热点数据加入redis缓存中。
- 缓存污染：部分缓存数据被访问次数很少，占用缓存空间。

# 16.redis LRU算法知道吗？写一下java代码实现？

实现LinkedHashMap，使用 LinkedHashMap(int initialcapacity,float loadfactor,boolean accessorder)

- 第三个参数设置为true，**代表按访问顺序排序，可作为LRU缓存。设置为false 代表按插入顺序排序，可作为FIFO缓存。**
- 同时实现removeEldestEntry这个方法返回return size() > maxCapacity。

LRU算法实现：
- 1.通过双向链表来实现，新数据插入到链表头部；
- 2.每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
- 3.当链表满的时候，将链表尾部的数据丢弃。


# 17.redis回收策略：

- **惰性删除**：
  读删除：用于当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空，这种策略是出于节省cpu成本考虑，不需要单独维护ttl链表来处理过期键的删除。
  写删除：客服端运行新命令导致内存不足时，redis将根据回收策略回收。
- **定时任务删除**：redis内部维护一个定时任务，默认每秒运行10次。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例，使用快慢两种速率模式回收键。

- **内存淘汰策略**:
    - 1.noeviction:返回错误当内存限制达到
    - 2.allkeys-lru: 尝试回收最少使用的键（lru）
    - 3.volatile-lru: 尝试回收最少使用的键（lru），但仅限于在已设置有效期集合的键。
    - 4.allkeys-random: 回收随机的键使得新添加的数据有空间存放。
    - 5.volatile-random: 回收随机的键，但仅限于在有效期集合的键。
    - 6.volatile-ttl: 回收在有效期集合的键，并且优先回收存活时间较短的键。
    - 7.allkeys-lfu: 尝试回收使用频率最低的键（LFU）
    - 8.volatile-lfu: 尝试回收使用频率最低的键（LFU），但仅限于在已设置有效期集合的键。

# 18.redis做异步队列的实现

- 异步队列：使用list结构作为队列，rpush生产消息，lpop消费消息。
- 延迟队列：
  - 基于过期事件监听(不靠谱、key删除时才会有通知，会延迟的)
  - 使用sortedset，使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。

有以下问题：

  + 数据可靠性：如果消费者在接收到消息后立即下线,消息未正常消费丢失。
  + 数据持久化：redis作为内存数据库，存储容量受服务器物理内存限制，不适合海量数据，系统故障时可能会存在数据丢失风险。
  + 复杂性：实现可靠的消息传递和错误恢复机制可能需要额外的代码和设计，这增加了系统的复杂性。
  + 不适用于大规模分布式系统：不支持分区、消费组、消息重试、强大的一致性保证。

# 19、redis中只存20w的数据，如何保证redis中的数据都是热点数据？

redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略allkeys-lru，计算预估出20w数据所占空间，然后将redis限制为此数，同时设置redis回收策略为allkeys-lru回收最少使用.

# 20.Redis cluster集群为啥要求最少三个master节点，并且是奇数？

- 虽然Redis集群采用了无中心化设计思想， 但是cluster各节点之间需要互相通信确认对方是否存活，如果少于3个主节点，会产生网络分区问题，无法确认哪个节点异常。
- 奇数是为了解决投票选举时，得到多数派的支持。

# 21.谈谈Redis的哈希槽和一致性哈希

> hash 算法（大量缓存重建）
> 一致性Hash算法，这种算法在适用代理集群方案中，主要在外部的代理模式 （Twemproxy）。 一致性Hash算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）。
> 官方Slot 哈希槽算法 ，这种算法就是 Cluster 的核心算法

在 Redis 3.0 之前，Redis 是没有集群方案的，在这个时期实现 Redis的分布式主要由客户端自行实现。一般的实现方式就是一致性Hash。
而 Redis 3.0 之后 ，Redis 实现了 Cluster 集群，也就采用了相对而言更简洁的 Slot 槽方式。

# 30.分布式限流网关组件

**使用Redis+Lua来开发**,无论是Nginx外部网关还是Zuul内部网关，都可以使用Redis+Lua限流组件.理论上，接入层的限流有多个维度：
（1）用户维度限流：在某一时间段内只允许用户提交一次请求，比如可以采取客户端IP或者用户ID作为限流的key。
（2）商品维度的限流：对于同一个抢购商品，在某个时间段内只允许一定数量的请求进入，可以采取秒杀商品ID作为限流的key。

- nginx限流场景：
  + 用户维度的限流，可以在nginx上进行，因为使用nginx限流内存来存储用户id，比用redis 的key，来存储用户id，效率高。
- redis+lua分布式限流：
  + 商品维度的限流，可以在redis上进行，不需要大量的计算访问次数的key，另外，可以控制所有的接入层节点的访问秒杀请求的总量。

# 31.说一下 mongoDB

MongoDB是一种NoSQL数据库，它采用文档存储方式，支持动态查询和索引。下面是MongoDB的特性、优缺点和应用。

特性：

- **支持动态查询和索引** ：MongoDB使用BSON（Binary JSON）格式存储数据，支持动态查询和索引，可以快速查询和分析数据。
- **支持复制和故障转移** ：MongoDB支持复制和故障转移，可以保证数据的高可用性和可靠性。
- **支持分片** ：MongoDB支持自动分片，可以扩展到大规模数据集。
- **支持MapReduce** ：MongoDB支持MapReduce，可以进行复杂的数据分析和聚合。
- **支持全文搜索** ：MongoDB支持全文搜索，可以对文本进行高效的搜索和分析。

优点：

- **高性能** ：MongoDB采用内存映射和预分配空间等技术，可以实现高性能的读写操作。
- **易于扩展** ：MongoDB支持自动分片和复制，可以方便地进行扩展。
- **灵活性** ：MongoDB采用文档存储方式，可以方便地存储结构不固定的数据。
- **易于使用** ：MongoDB使用简单，支持多种编程语言和平台。

缺点：

- **不支持事务** ：MongoDB不支持多文档事务，只支持单文档事务。
- **存储空间占用较大** ：MongoDB采用BSON格式存储数据，存储空间占用较大。
- **不支持复杂查询** ：MongoDB不支持复杂查询，如多表连接等。

应用：

- **Web应用** ：MongoDB可以用于Web应用的数据存储和查询。
- **大数据分析** ：MongoDB支持MapReduce，可以用于大数据分析。
- **日志处理** ：MongoDB可以用于日志处理和分析。
- **移动应用** ：MongoDB可以用于移动应用的数据存储和查询。



