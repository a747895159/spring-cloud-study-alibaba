https://www.cnblogs.com/crazymakercircle/p/14285001.html

[TOC]

# 1.服务雪崩

- 多个微服务调用,比如服务A调用服务B、服务B又调用服务C、服务C又调用其他... 就是**扇出**。
- 当扇出的链路上某个服务调用时间过长或不可用时，微服务A的调用就会占用越来越多的资源，进而引起系统崩溃。
- 也同时会引起其他接口服务调用延迟，系统资源紧张，发生级联故障。
  此时需要需要服务链路做熔断、降级方案，防止雪崩。

# 2.服务熔断、降级、隔离、限流的理解

+ **降级**：根据实际业务情况，从资源保护和系统负载均衡的角度出发，客户端（调用方）对一些服务和页面进行有策略的不处理。
	- **超时降级**： 根据超时响应时间与重试机制，自动返回服务预期的响应(FallBack)
	- **失败次数降级**：对一些API调用，当失败次数或失败率达到一定的阈值时
	- **故障降级**：要调用的远程服务挂了，直接返回一些兜底处理方案(使用之前缓存数据等)
	- **限流降级**：对一些可预见的访问量大接口，提前做好限流配置，保护系统稳定。当超过限流阈值，直接返回错误提示。
	- **主要是有客户端设置,一般由外围业务开始,牺牲非核心服务，保证核心服务稳定；从整体负荷考虑**

+ **熔断**：是一种框架级别的保护机制，客户端（调用方）对服务方的请求和调用出现大量失败和超时,这时熔断该服务的所有调用,从而快速释放资源。
	- 熔断器状态：
		- **Closed**：熔断器关闭状态，调用失败次数积累，到了阈值（或一定比例）则启动熔断机制；
		- **Open**：熔断器打开状态，此时对下游的调用都内部直接返回错误，不走网络，但设计了一个时钟选项，默认的时钟达到了一定时间（这个时间一般设置成平均故障处理时间，也就是MTTR），到了这个时间，进入半熔断状态；
		- **Half-Open**：半熔断状态，允许定量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态；
+ **隔离**：服务方为保护整体资源不被某些接口资源耗尽，这些接口配置最大可以使用的资源。
+ **限流**：对一些可预见的访问量大接口，提前做好限流配置，保护系统稳定。支持多种维度控制(请求参数、IP、Header等)。隔离在一定维度上也是限流。

+ 降级、熔断是对客户端（调用方）的保护。隔离、限流是对服务方的保护。

# 3.两种资源隔离方式

![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210823201516541-1750466451.png)

- 线程池隔离
	- 优点:
		- 控制并发：通过线程池大小限制了对特定服务的并发调用数，有助于防止服务过载。
		- 支持阻塞操作：不会占用 Tomcat 的工作线程。
	- 缺点:
		- 资源开销：每个服务都需要维护一个线程池，增加了内存消耗和管理成本。
		- 上下文切换：线程间的上下文切换会带来额外的性能开销。
		- 过度隔离：对于轻量级服务，使用线程池可能过于重，导致资源浪费。

![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210823201306949-2140770679.png)

- 信号量隔离
	- 优点:
		- 轻量级：通过计数器限制并发数，实现简单。不涉及线程的创建和销毁，减少了资源开销和上下文切换的开销。
		- 高效：适用于非阻塞、快速完成的操作，能够提供更高的吞吐量。
	- 缺点:
		- 不支持阻塞操作：Tomcat 工作线程被阻塞，影响整体响应能力。
		- 资源利用不足：对于快速完成的任务，信号量可能过早地拒绝请求，即使系统有能力处理更多并发。
		- 缺乏灵活性：相较于线程池，信号量在处理复杂场景和提供高级特性（如超时、降级策略）方面较为有限。

> 示例：A 调用B、C、D时，当BCD之间没有逻辑依赖关系。
> 1.在B做线程池隔离时，不阻塞Tomcat工作线程，会继续调用C/D
> 2.在B做信号量隔离时，阻塞Tomcat工作线程，需等待B处理完。


# 4.限流算法原理

+ 1.固定窗口限流算法：
	- 定义：单位窗口时间内当次数少于限流阈值,就允许访问。否则拒绝。当前时间窗口过去后，计数器清零。
	- 缺点：临界问题,算法存在不精确。比如：1s内可以访问5次,在0.8-1s内访问5次， 而在 1s-1.2s也访问5次。这样就存在超过1s内访问5次的限制。

+ 2.滑动窗口限流算法:
	- 解决固定窗口临界值问题,将单位时间周期分为N个周期,分别记录每个小周期方位次数,根据滑动时间删除过期的小周期
	- 滑动窗口周期划分越多,那么滑动窗口的滚动就越平滑,限流统计越精确。
	- 固定窗口与滑动窗口都存在暴力拒绝,会损失一部分请求,不友好。

+ 3.漏桶算法：
	- 往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃
	- 系统按照固定的速率处理请求，是我们想要的。但是面对突发流量的时候，漏桶算法处理不算友好。

+ 4.令牌桶算法：
	- 以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。
	- 除了要求能够限制数据的平均传输速率外，还要求允许某种程度的**突发传输**。这时候漏桶算法可能就不合适了，令牌桶算法更为适合
	- 示例：Guava的RateLimiter就是令牌桶算法。
	- 使用场景：
		- 漏桶算法：恒定速率流出，不支持突发流量。用户防止打垮我们依赖的服务，适用于因第三方服务固定速率限流的
		- 令牌桶算法：适用于我们自己维护的服务,面对突发情况,为保证系统最大可用性,防止服务被打垮。

  ![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210823173621224-1814502732.png)


# 4.Hystrix 与 Sentinel 的区别

都是用于构建高可用微服务架构的容错库，它们的核心功能确实包括服务降级、熔断、隔离和回退策略。

### 相同点：

- 都支持线程池隔离、信号量隔离。
- 都支持熔断降级（响应时间、失败比率），达到快速失败。
- 都是基于滑动窗口实现，支持多种数据源配置、扩展好，支持注解方式引入。

### 不同点

- Sentinel 在功能上更加全面，支持限流，友好的控制台配置页面、可以展示各种配置与监控。社区维护活跃。Sentinel v1.8 文档手册](https://www.bookstack.cn/read/Sentinel-1.8/2ed1babeee77ea56.md)

	- 集群流控：分布式微服务对某个API限制总QPS。
	- 网关流控：根据限流规则，对用户自定义(请求中的参数、Header、来源 IP)的分组进行限流.
	- 热点参数限流：某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制
	- 系统自适应限流： 应用的 Load、总体平均 RT、入口 QPS 和线程数等几个维度的监控指标，让系统的入口流量和系统的负载达到一个平衡
	- 黑白名单限制：根据请求来源(origin)限制
	- 基于配置中心自定义动态规则：将控制规则保存在配置中心（Nacos、Apollo、Zookeeper、Redis ），以 **推模式** 实时获取动态规则。

- Hystrix 主要关注的是通过线程池和信号量机制来实现服务的资源隔离和熔断。限流方面支持比较薄弱，2019年进入维护模式，停止新功能开发，不支持各维度的限流，限流能力较弱。


| 对比项目       | Sentinel                                                     | Hystrix                    |
  | -------------- | ------------------------------------------------------------ | -------------------------- |
| 隔离策略       | **默认信号量**/线程池                                        | 信号量/**默认线程池**      |
| 熔断降级策略   | 基于响应时间、失败比率                                       | 基于响应时间、失败比率     |
| 实时指标实现   | 滑动窗口                                                     | 滑动窗口(RxJava)           |
| 扩展性         | 多个扩展点                                                   | 插件的形式                 |
| 注解的支持     | 支持                                                         | 支持                       |
| 限流           | 基于QPS，支持调用关系，支持各维度（IP、参数、请求Header）流控 | 不支持                     |
| 流量整形       | 支持慢启动，匀速器模式                                       | 不支持                     |
| 系统自适应保护 | 支持                                                         | 不支持                     |
| 控制台         | 可配置规则、秒级监控，限流图形界面化                         | 不完善，仅有限流图形界面化 |
| 活跃度         | 阿里维护，社区活跃度高                                       | 2019年停止更新，仅维护     |




# 5.应用级限流

+ 单实例应用级限流
	- SpringBoot 内嵌Tomcat,默认配置：最大工作线程数 200,最小工作线程数 10,最大连接数 10000, 当前连接数超过maxConnections时，还能接受的连接的数量（排队的数量） 100。
	- 使用Java 信号量
	- Hystrix
	- Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。

+ 分布式限流
	- 业务上限流可以使用redis+lua或者nginx+lua技术进行实现
	- Sentinel基于QPS全服务限流

+ 接入层限流
	- Nginx流量控制
		- limit_conn用来对某个KEY对应的总的网络连接数进行限流，可以按照如IP、域名维度进行限流。
		- limit_req用来对某个KEY对应的请求的平均速率进行限流，并有两种用法：平滑模式（delay）和允许突发模式(nodelay)。



# 6.设计限流组件，要考虑哪些因素

- 1.限流维度：http请求限流(配置在Nginx)、特定接口参数限流(需要接口层实现限流)
- 2.限流算法: 固定窗口法、漏斗法，以及令牌桶法，还有一些组件实现了具有预热功能的算法.
- 3.限流数据保存：Redisson 是保存在redis,Sentinel 保存在内存利用了Google开源的ConcurrentLinkedHashMap，利用它实现了LRU。
- 4.限流的数据量级：小数据量忽略、大数据量 要有一个存放空间已经过期策略。
- 5.时钟回拨或抖动,精细限流(毫秒级限流)就有问题。解决思路，重新获取时间。Redis-cell源码中就采用了这一方案。



