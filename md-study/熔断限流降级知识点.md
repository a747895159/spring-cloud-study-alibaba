
https://www.cnblogs.com/crazymakercircle/p/14285001.html

[TOC]

# 1.服务雪崩
- 多个微服务调用,比如服务A调用服务B、服务B又调用服务C、服务C又调用其他... 就是**扇出**。
- 当扇出的链路上某个服务调用时间过长或不可用时，微服务A的调用就会占用越来越多的资源，进而引起系统崩溃。
- 也同时会引起其他接口服务调用延迟，系统资源紧张，发生级联故障。


# 2.服务限流、熔断、降级的理解
+ **服务降级**：当服务器压力剧增的情况下，根据实际业务情况，对一些服务和页面进行有策略的不处理。从而保证和信息业务正常运行。
	- **超时降级**： 根据超时响应时间与重试机制，自动返回服务预期的响应(FallBack)
	- **失败次数降级**：对一些API调用，当失败次数或失败率达到一定的阈值时
	- **故障降级**：要调用的远程服务挂了，直接返回一些兜底处理方案(使用之前缓存数据等)
	- **限流降级**：对一些可预见的访问量大接口，提前做好限流配置，保护系统稳定。当超过限流阈值，直接返回错误提示。
	- **主要是有客户端设置,一般由外围业务开始,牺牲非核心服务，保证核心服务稳定；从整体负荷考虑**
	
+ **服务熔断**：对目标服务的请求和调用出现大量失败和超时,这时熔断该服务的所有调用,从而快速释放资源。
	- 熔断器状态：
		- **Closed**：熔断器关闭状态，调用失败次数积累，到了阈值（或一定比例）则启动熔断机制；
		- **Open**：熔断器打开状态，此时对下游的调用都内部直接返回错误，不走网络，但设计了一个时钟选项，默认的时钟达到了一定时间（这个时间一般设置成平均故障处理时间，也就是MTTR），到了这个时间，进入半熔断状态；
		- **Half-Open**：半熔断状态，允许定量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态；
		
+ **服务限流**：为保护服务不被大量请求冲垮，通过限制请求速度与次数来保护系统。可以认为是服务降级的一种实现方式。
	



# 3.限流算法原理

+ 1.固定窗口限流算法：
	- 定义：单位窗口时间内当次数少于限流阈值,就允许访问。否则拒绝。当前时间窗口过去后，计数器清零。
	- 缺点：临界问题,算法存在不精确。比如：1s内可以访问5次,在0.8-1s内访问5次， 而在 1s-1.2s也访问5次。这样就存在超过1s内访问5次的限制。
+ 2.滑动窗口限流算法:
	- 解决固定窗口临界值问题,将单位时间周期分为N个周期,分别记录每个小周期方位次数,根据滑动时间删除过期的小周期
	- 滑动窗口周期划分越多,那么滑动窗口的滚动就越平滑,限流统计越精确。
	- 固定窗口与滑动窗口都存在暴力拒绝,会损失一部分请求,不友好。
+ 3.漏桶算法：
	- 往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃
	- 系统按照固定的速率处理请求，是我们想要的。但是面对突发流量的时候，漏桶算法处理不算友好。

+ 4.令牌桶算法：
	- 以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。
	- 除了要求能够限制数据的平均传输速率外，还要求允许某种程度的**突发传输**。这时候漏桶算法可能就不合适了，令牌桶算法更为适合
	- 示例：Guava的RateLimiter就是令牌桶算法。
	- 使用场景：
		- 漏桶算法：恒定速率流出，不支持突发流量。用户防止打垮我们依赖的服务，适用于因第三方服务固定速率限流的
		- 令牌桶算法：适用于我们自己维护的服务,面对突发情况,为保证系统最大可用性,防止服务被打垮。
		

	![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210823173621224-1814502732.png)




# 4.限流框架原理及比较

- 单机版JDK: 自带的锁、信号量等、Guava的RateLimiter、Hystrix(基于单体应用线程池/信号量 隔离)
- 分布式： Redis 4.0 版本中提供的 Redis-Cell  、Redisson（基于lua脚本实现）、Sentinel(基于QPS全服务限流)

- Hystrix 的信号量隔离：
	- 防止阻塞扩散, 与线程隔离最大不同在于执行依赖代码的线程依然是请求线程,减少线程切换的CPU损耗与分配线程的内存损耗,
	- ![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210823201306949-2140770679.png)
	
- Hystrix 的线程池隔离：
	- 默认使用线程池隔离,把执行依赖代码的线程与请求线程分离，请求线程可以自由控制离开的时间(异步过程)
	- ![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210823201516541-1750466451.png)

- sentinel 滑动窗口实现原理
	- 可以实现集群流控：分布式微服务对某个API限制总QPS
	- 网关流控：根据限流规则，对用户自定义(请求中的参数、Header、来源 IP)的分组进行限流.
	- 熔断降级：调用链路中的某个资源不稳定,这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误
	- 热点参数限流：某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制
	- 系统自适应限流： 从整体维度对应用入口流量进行控制，结合应用的 Load、总体平均 RT、入口 QPS 和线程数等几个维度的监控指标，让系统的入口流量和系统的负载达到一个平衡
	- 黑白名单限制：根据请求来源(origin)限制
	- 基于配置中心自定义动态规则：将控制规则保存在配置中心（Nacos、Apollo、Zookeeper、Redis ），以 **推模式** 实时获取动态规则
	- 控制台：友好的控制台配置页面、可以展示各种配置与监控
	- [Sentinel v1.8 文档手册](https://www.bookstack.cn/read/Sentinel-1.8/2ed1babeee77ea56.md)
	
	![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210823195618832-1372124985.png)



# 5.设计限流组件，要考虑哪些因素

- 1.限流维度：http请求限流(配置在Nginx)、特定接口参数限流(需要接口层实现限流)
- 2.限流算法: 固定窗口法、漏斗法，以及令牌桶法，还有一些组件实现了具有预热功能的算法.
- 3.限流数据保存：Redisson 是保存在redis,Sentinel 保存在内存利用了Google开源的ConcurrentLinkedHashMap，利用它实现了LRU。
- 4.限流的数据量级：小数据量忽略、大数据量 要有一个存放空间已经过期策略。
- 5.时钟回拨或抖动,精细限流(毫秒级限流)就有问题。解决思路，重新获取时间。Redis-cell源码中就采用了这一方案。


# 6.应用级限流

+ 应用级限流
	- SpringBoot 内嵌Tomcat,默认配置：最大工作线程数 200,最小工作线程数 10,最大连接数 10000, 当前连接数超过maxConnections时，还能接受的连接的数量（排队的数量） 100。
	- Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。
	- 使用Java 信号量
	- Hystrix
	
+ 分布式限流
	- 业务上限流最关键的是要将限流服务做成原子化，而解决方案可以使使用redis+lua或者nginx+lua技术进行实现，通过这两种技术可以实现的高并发和高性能。
	- Sentinel
	
+ 接入层限流
	- 接入层通常指请求流量的入口，该层的主要目的有：负载均衡、非法请求过滤、请求聚合、缓存、降级、限流、A/B测试、服务质量监控等等，可以参考笔者写的《使用Nginx+Lua(OpenResty)开发高性能Web应用》。
	- 对于Nginx接入层限流可以使用Nginx自带了两个模块：连接数限流模块ngx_http_limit_conn_module和漏桶算法实现的请求限流模块ngx_http_limit_req_module。
		- limit_conn用来对某个KEY对应的总的网络连接数进行限流，可以按照如IP、域名维度进行限流。
		- limit_req用来对某个KEY对应的请求的平均速率进行限流，并有两种用法：平滑模式（delay）和允许突发模式(nodelay)。
		- 还可以使用OpenResty提供的Lua限流模块lua-resty-limit-traffic进行更复杂的限流场景。[《使用Nginx+Lua(OpenResty)开发高性能Web应用》](https://www.iteye.com/blog/jinnianshilongnian-2280928)
		

# 7.Hystrixde 定义
+ 是一个应用于处理分布式系统的延迟和容错的开源框架。可以保证一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，提高分布式系统的容错性。
+ **断路器** 本身是一种开关装置，当某个服务发生故障后，通过断路器的故障监控，向返回方直接返回一个服务预期的响应(FallBack),而且不是长时间等待，这样就保障了调用方线程不会被拉长。



















































