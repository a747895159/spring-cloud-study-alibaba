[TOC]
----

# 1.redis基本数据类型，应用场景？

高性能：纯内存操作、是基于非阻塞的 IO 多路复用机制、单线程反而避免了多线程的频繁上下文切换问题。
Redis6.0的多线程是用多线程来处理数据的读写和协议解析，但是 Redis执行命令还是单线程的。Redis 的性能瓶颈在于⽹络 IO ⽽⾮ CPU，使⽤多线程能提升 IO 读写的效率。
![](https://img2024.cnblogs.com/blog/1694759/202407/1694759-20240724194545113-88476700.png)

![](https://p5.toutiaoimg.com/origin/tos-cn-i-qvj2lq49k0/a0e48f0d04814c8bb8536cc93b0b0c9a?from=pc)

- **String** （字符串）：适用于存储文本、数字等数据，底层使用动态字符串SDS。常见用途包括缓存、计数器、会话管理等。
- **Hash** （哈希表）：适合存储对象（如用户数据、商品信息）的多个字段及其值。能快速检索或修改字段值。
- **List** （列表）：用于保存有序的元素序列。适用于实现消息队列、栈、发布订阅等功能。
- **Set** （集合）：用于保存不重复的元素。适用于存储标签、好友列表等，也可用于计算交集、并集等操作。
- **Sorted Set** （有序集合）：类似于 Set，但每个元素都有一个分数，可用分数对元素进行排序。适用于实现排行榜、优先级队列等。
- **Bitmap** （位图）：适合存储布尔值，可用于追踪用户在线状态、用户活跃度等。能执行位运算以统计和查询状态。
- **HyperLogLog** ：用于估算集合中不重复元素的数量，适用于统计 UV（独立访客数）等场景。
- **Geospatial** （地理空间）：用于存储地理位置信息，支持距离计算和附近位置的查询。适合实现地图应用、位置服务等。
- **Pub/Sub** （发布订阅）：用于实现消息发布和订阅机制，业务场景能够接受其“无消息持久化”的特点，例如实时聊天、配置刷新、轻量级的系统内部事件通知等等。

# 2.redis三大客户端选型

- **Jedis客户端**：提供了比较全面的Redis命令的支持。
    - 缺点：阻塞的I/O，不支持异步；客户端实例线程不安全，需要通过连接池来使用。
- **Lettuce客户端**：可扩展的线程安全的Redis客户端，支持异步IO。基于Netty框架实现。支持高级Redis特性，如集群、Sentinel、管道和编码器的支持。**Spring Boot2.0 默认使用的Redis客户端是Lettuce**。
- **Redisson客户端**：是一个在 Redis 的基础上实现的 Java 驻内存数据网格。线程安全的客户端，基于Netty的非阻塞I/O，性能较高。提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列。
    - 缺点：Redisson 对字符串的操作支持比较差；不支持排序、事务、管道、分区等Redis特性。

**使用建议：lettuce + Redisson**


# 3.Redisson分布式锁简介

- Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock)、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。
- RLock结构 key就是UUID+threadId，采用**hash结构**的value就是重入值，在分布式锁时，这个值为1（Redisson还可以实现重入锁，那么这个值就取决于重入次数了）。

```
# lua脚本 获取锁  KEYS[1]代表key，ARGV[1]代表过期时间，ARGV[2]代表[UUID+线程id]
"if (redis.call('exists', KEYS[1]) == 0) then " +
  "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
  "return nil; " +
  "end; " +
  "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
  "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
  "return nil; " +
  "end; " +
  "return redis.call('pttl', KEYS[1]);",
  
```

```
# lua脚本 释放锁 KEYS[1]代表key，ARGV[2]代表过期时间，ARGV[3]代表[UUID+线程id]
"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then " +
  "return nil;" +
  "end; " +
  "local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); " +
  "if (counter > 0) then " +
  "redis.call('pexpire', KEYS[1], ARGV[2]); " +
  "return 0; " +
  "else " +
  "redis.call('del', KEYS[1]); " +
  "redis.call('publish', KEYS[2], ARGV[1]); " +
  "return 1; " +
  "end; " +
  "return nil;"
```

- 联锁，其实就是将多个RLock形成一个锁组合，遍历组合内各个key，分别去获取锁，失败一个全部失败。场景：一个订单中有多种商品，提交订单的时候，每种商品的库存需要被扣除。
- 红锁：多个独立节点，客户端申请分布式锁时，向所有实例发送申请，超过半数则成功。场景：避免Redis极端场景主宕机问题。


# 4.Redis中hash与HashMap 的区别？

- 从存储结构上,redis的hash小数据量的时候采用的是 **压缩列表，大数量是采用的是哈希表**。
- 从哈希冲突来看,redis的hash采用开放地址法（线性探针法）来解决键的冲突，HashMap采用的是链地址法
  - redis设计为了不需要额外的指针,减少内存使用,当装载因子增大时，冲突增多。所以redis扩容时，采用渐进式Rehash。
  - HashMap为了均衡频繁的插入、删除、查找等操作，提供良好的性能，采用链地址法。
- 从数据结构来看，redis的hash和java的HashMap很像，**区别在于rehash**：
    - HashMap在resize时是一次性拷贝的，然后使用新的数组，多线程协同扩容，迁移过程中线程阻塞。
    - Redis是渐进式rehash，后台单线程定时进行扩容迁移，可以避免因扩容导致的线程卡顿现象。使用2个哈希表，读操作：会先去ht[0]中找，找不到再去ht[1]中找。写操作：直接写在ht[1]中。

| 特性           | 链地址法       | 开放地址法                                         |
| :------------- | :------------- | :------------------------------------------------- |
| **数据结构**   | 数组 + 链表    | 一个更大的纯数组                                   |
| **内存开销**   | 有指针开销     | **无指针开销**，但数组更大                         |
| **缓存性能**   | 不友好         | **友好，缓存局部性**                               |
| **删除操作**   | **简单**       | **复杂**（需墓碑标记）                             |
| **装载因子**   | 可 > 1，不敏感 | 必须 < 1，**极度敏感**                             |
| **实现难度**   | 简单           | 较复杂                                             |
| **性能稳定度** | **更稳定**     | 不稳定，装载因子高时性能**急剧下降**，追求极致性能 |

**链地址法是一个稳健的“工程师”，而开放地址法是一个需要精心调教的“赛车手”**。

Java `ThreadLocalMap`这种**条目少、访问频繁**的数据结构，利用开放地址法带来的**缓存友好性**对性能的提升是巨大的。

Redis 基于开放地址法，**缓存局部性，极致的内存管理效率**。采用**渐进式Rehash**方式避免装载因子问题。

# 6.Redis持久化方案与主从同步

- AOF:先执行命令，把数据写入内存，然后才记录日志。三种写会策略：Always(同步写)、EverySec(每秒写)、NO(操作系统控制)。
- AOF重写机制：当AOF文件体积达到一定大小时，会触发重写机制，由后台线程 bgrewriteaof 来完成的，然后删除AOF文件。
- RDB：记录某一时刻的全量快照数据。bgsave命令后台子进程完成，不阻塞主线程。save命令主线程执行，会导致阻塞。
- RDB+AOF混合是持久化，定期全量快照数据RDB + 增量AOF。
  + 1.AOF文件持续记录增量命令。
  + 2.当触发AOF重写（BGREWRITEAOF）时，Redis会先 fork 子进程，将当前内存数据以RDB二进制格式写入新的AOF文件作为前缀（Preamble）。
  + 3.然后，子进程再将重写缓冲期内的增量写命令（以AOF格式）追加到这个RDB数据后面。
  + 4.最终生成的新AOF文件是一个前半部分是RDB快照，后半部分是增量AOF日志的混合体。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521152458432-1912275025.png)

![](https://img2024.cnblogs.com/blog/1694759/202407/1694759-20240724195755184-2100451939.png)


# 7.关于 redis，说一下 sorted set 底层原理

Redis 的 sorted set 是一种有序集合，它的底层实现是使用了 **跳表（Skip List）和哈希表（Hash Table）** 这两种数据结构。

- **跳表**是一种类似于链表的数据结构，但是它在每个节点上增加了多个指针，可以快速地跳过一些节点，从而提高了查找效率。
- **哈希表**则是一种以键值对形式存储数据的数据结构，可以快速地进行数据的插入、查找和删除操作。采用开放地址法（线性探针法）来解决键的冲突
  在 Redis 的 sorted set 中，每个元素都有一个分数（score），根据分数的大小来进行排序。使用跳跃表可以快速地进行分数的比较和排序，而使用哈希表可以快速地进行元素的查找和删除操作。
- Redis 还使用了**压缩列表（Ziplist）**来优化存储空间，对于一些小的 sorted set，它们的元素可以被存储在一个压缩列表中，从而减少了内存的使用。



# 8.分布式缓存 Redis与DB数据一致性解决方案

若系统严格要求 “缓存+数据库” 必须保持一致性的话，可以使用：读请求和写请求串行化，串到一个内存队列里去，吞吐量大幅度降低。

- 缓存是通过牺牲强一致性来提高性能的,由CAP理论决定的。缓存系统适用的场景就是非强一致性的场景，它属于CAP中的AP。
- 双删机制: 先删缓存、**更新数据库、再删缓存**。
- Canal+RocketMQ同步MySQL，由BinLog消息统一进行删除缓存。
- 旁路缓存(Cache Aside Pattern):
  - 先读缓存，没有的话再读数据库，然后放入缓存，同时返回响应。
  - 更新的时候，先更新数据库，然后再删除缓存(懒加载思想)，因为更新数据库的速度比删除缓存的速度要慢得多。

# 9.如何解决缓存热点（热key）问题？

- 本地缓存caffeine + 分布式缓存redis.以下是多级缓存注解事项：
- 本地缓存要解决JVM内存问题，不适合存储大量数据,需要对缓存大小进行评估。
- 本地缓存数据应设置效期和合理的淘汰策略,建议使用caffeine,策略是LRU+LFU，既具有较好的时间局部性，又具有大部分数据场景。
  - 考虑设置定时任务来同步缓存，以防止极端情况下数据丢失。
  - 当应用重启时，本地缓存会失效，因此需要注意加载分布式缓存的时机。
  - 当本地缓存失效时，需要使用 synchronized 进行加锁，确保由一个线程加载 Redis 缓存，避免并发更新。
  - 如果业务能够接受短时间内的数据不一致，那么本地缓存更适用于读取场景。
  
```
  Cache<String, Map<Integer, String>> cache = Caffeine.newBuilder().expireAfterWrite(5, TimeUnit.MINUTES).maximumSize(500).build();
```

### 如何保证本地缓存和Redis缓存一致
- 设置本地缓存的过期时间，当缓存过期时，直接从Redis中同步，
- 使用基于Redis的Pub/Sub机制(广播模式)，当 Redis 缓存发生变化时，发布一个消息，本地缓存订阅这个消息，然后删除对应的本地缓存。
- 或者使用消息队列，当 Redis 缓存发生变化时，发布一个消息，本地缓存订阅这个消息，然后删除对应的本地缓存。

通常对于频繁访问但不经常更改的数据，可以放在本地缓存中以提供最快的访问速度。而对于需要共享或者一致性要求较高的数据，应当放在Redis缓存中。


# 10.什么是BigKey

* 【字符串类型】： 单个 string 类型的 value 值超过 1MB，就可以认为是 Bigkey。
* 【非字符串类型】：哈希、列表、集合、有序集合等， 它们的元素个数过万个，就可以认为是 Bigkey。

使用bigkeys命令分析，大key存在问题：

- **造成 Redis 集群中数据倾斜**
- **侵占带宽网络拥堵**
- **数据请求大量超时**: redis是单线程的，当一个key数据响应的久一点，就会造成后续请求频繁超时
- **内存溢出或处理阻塞**：可以过大时会导致内存数据溢出；同时过期删除时，由于数据量过大，会影响主从同步。

解决方案： 将BigKey进行业务拆分，分成多个小key。



# 11.什么是热key(HotKey)

某个key频繁被访问，访问次数显著高于其他key，单点访问频率过高，占用大量资源。

存在问题：

- **分片服务瘫痪**: 同一个实例下某个key访问量很高，占用某个分片大量资源，而其他分片访问较少。

- **cpu占用高，影响其他服务**: 单个分片cpu占用率过高，其他分片无法拥有cpu资源，从而被影响

- **引发缓存击穿**: 当缓存请求不到会去请求数据库。如果请求过于集中，redis承载不了，就会有大量请求打到数据库。**此时，可能引发数据库服务瘫痪。进而引发系统雪崩** 。

解决方案： 1.用本地缓存； 2.热Key加上前缀或者后缀分散到不同的服务器上。



# 12.Redis为啥设计成16384个槽

- redis节点发送心跳包时需要把所有的槽放到这个心跳包里，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 * 8 (8 bit) * 1024(1k) = 16K）个char，也就是说使用2k个char的空间，能表达16k的槽数。
- 使用CRC16算法求key对应上的slot,CRC16最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（8 * 8 (8 bit) * 1024(1k) =65K），也就是说需要需要8k的心跳包，作者认为这样做不太值得。
- 集群节点越多，心跳包的消息体内携带的数据越多，如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。


# 13.Redis脑裂问题

Redis脑裂是指在一个Redis集群中，由于某些原因（如网络问题、配置错误等），导致集群中的多个节点无法相互通信，进而造成数据不一致和丢失的现象。脑裂现象对于Redis集群的稳定性和数据完整性构成了严重威胁。

脑裂问题的发生通常涉及以下几个方面：

- 网络问题：在网络不稳定或者分区的情况下，Redis集群中的节点之间可能无法正常通信，从而导致脑裂现象。
- 配置错误：如果Redis集群的配置不当，比如节点间的超时时间设置不合理，或者节点数量过多导致通信压力增大，都可能增加脑裂发生的风险。
- 主从切换问题：在Redis的主从复制架构中，如果主节点宕机，从节点需要通过选举来升级为新的主节点。在这个过程中，如果旧的主节点重新上线并且继续处理写请求，就会与新的主节点形成两个主节点并存的局面，导致脑裂。


# 14.redis事务与lua脚本的区别

- Pipelining（管道技术）: 多个命令合并发送到redis服务器，减少网络传输次数，减少网络读写的上下文切换，提高效率。
- redis事务：基于乐观锁，多个client对操作的key进行watch，一旦有一个client进行了exec，那么其它client的exec就会失效。类似CAS操作。
    - 一次性批量执行多条命令,具有弱原子性,中途出现错误，Redis也会继续执行事务中剩余的命令，会造成数据不一致，不支持回滚。
    - multi(开启事务)、exec(提交事务)、discard(放弃事务)、watch(当被监控的键被修改后取消之后的事务)
  > 执行事务之前，使用WATCH命令监视一个或多个键
  > 使用MULTI命令标记事务的开始，之后的所有写命令都会被缓存起来，直到EXEC命令被执行。
  > 使用EXEC命令提交事务并执行所有缓存的命令。此时，Redis会再次检查被WATCH的键是否被修改过。如果没有被修改，事务正常执行；如果被修改过，事务将被放弃.
  > WATCH counter
  > MULTI
  > incr counter
  > EXEC

- lua脚本：基本原理为使脚本相当于一个redis命令，可以结合redis原有命令，自定义脚本逻辑。介于redis单线程模式，lua脚本具有**特定的原子性**。当服务器异常宕机，执行一半的命令也无法回滚。

- 相同点：都具有一定的原子性、隔离性，如果出现运行错误，都不支持回滚的。
- 不同点：**redis事务是一次性批量执行多条命令；lua脚本可以加入自定义逻辑,提供了更强的原子性**.

```java
@Autowired  
private RedisTemplate<String, String> redisTemplate;  

public Boolean setIfAbsentWithExpire(String key, String value, long timeout, TimeUnit timeUnit) {  
    String script = "if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then " +  
                    "redis.call('pexpire', KEYS[1], ARGV[2]) " +  
                    "return 1 " +  
                    "else " +  
                    "return 0 " +  
                    "end";
    RedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);  
    Number result = redisTemplate.execute(redisScript, Collections.singletonList(key), value, timeUnit.toMillis(timeout));
    return result.longValue() == 1L;  
}
```

# 15.缓存穿透、缓存击穿、缓存雪崩、缓存预热

- 缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时查询数据库。若流量大时，数据库可能会宕机。
    - 1.布隆过滤器：将所有可能存在的key放到一个足够大bitmap中。一定不存在的数据直接被bitmap拦截掉。
    - 2.短时缓存：若数据库查询的数据为空，扔把key缓存起来，设置一个短时间的过期时间。数据插入后清理。
- 缓存击穿：某个热点key失效后, 大并发访问, 导致数据库宕机。
    - 1.加锁排队：互斥锁对某个key只允许一个线程查数据写缓存，其他线程等待。
    - 2.设置热点Key 永不过期
- 缓存雪崩：缓存时集中在某一时段同时失效，请求全部转发到数据库，数据库瞬时压力过重导致雪崩效应。
    - 1.缓存时间增加随机值：每个缓存时间不一样，避免集体失效。
    - 2.集群方式，提高缓存可用性，避免单一节点故障风险。
- 缓存预热：系统上线前把热点数据加入redis缓存中。以避免在系统运行初期由于缓存未命中（cache miss）导致的性能问题。
- 缓存污染：部分缓存数据被访问次数很少，占用缓存空间。

# 16.Redis阻塞问题排查？

![](https://img2024.cnblogs.com/blog/1694759/202407/1694759-20240725101023719-311322344.png)

- **慢查询**：优化一些查询指令，禁用keys(使用scan替换)、sort等命令。
- **大key**：大对象拆分成多个小对象，防止一次指令操作过多的数据。
- **并发极限**: 如果redis请求并发几万+，需要进行扩容机器;如果并发很低，排查内存是否合理。
- **持久化相关的阻塞**：如果RDB和AOF重写时或者AOF刷盘(一般每秒一次)过快时，硬盘压力过大，也会出现阻塞主线程。


# 17.redis回收策略：

- **惰性删除**：
  读删除：用于当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空，这种策略是出于节省cpu成本考虑，不需要单独维护ttl链表来处理过期键的删除。
  写删除：客服端运行新命令导致内存不足时，redis将根据回收策略回收。
- **定时任务删除**：redis内部维护一个定时任务，默认每秒运行10次。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例，使用快慢两种速率模式回收键。

- **内存淘汰策略**:
    - 1.noeviction:返回错误当内存限制达到
    - 2.allkeys-lru: 尝试回收最少使用的键（lru）
    - 3.volatile-lru: 尝试回收最少使用的键（lru），但仅限于在已设置有效期集合的键。
    - 4.allkeys-random: 回收随机的键使得新添加的数据有空间存放。
    - 5.volatile-random: 回收随机的键，但仅限于在有效期集合的键。
    - 6.volatile-ttl: 回收在有效期集合的键，并且优先回收存活时间较短的键。
    - 7.allkeys-lfu: 尝试回收使用频率最低的键（LFU）
    - 8.volatile-lfu: 尝试回收使用频率最低的键（LFU），但仅限于在已设置有效期集合的键。

# 18.redis做异步队列的实现

- 异步队列：1.使用list结构作为队列，rpush生产消息，lpop消费消息；2.使用Redis的`pub/sub`(广播模式)来进行消息的发布/订阅.
- 延迟队列：
  - 基于过期事件监听(不靠谱、key删除时才会有通知，会延迟的)
  - 使用zset（有序集合），使用时间戳做score, 消息内容作为key,调用zadd来生产消息，消费者使用zrangbyscore获取n秒之前的数据做轮询处理。

有以下问题：

  + 数据可靠性：如果消费者在接收到消息后立即下线,消息未正常消费丢失。
  + 数据持久化：redis作为内存数据库，存储容量受服务器物理内存限制，不适合海量数据，系统故障时可能会存在数据丢失风险。
  + 复杂性：实现可靠的消息传递和错误恢复机制可能需要额外的代码和设计，这增加了系统的复杂性。
  + 不适用于大规模分布式系统：不支持分区、消费组、消息重试、强大的一致性保证。

![](https://img2024.cnblogs.com/blog/1694759/202510/1694759-20251022195045731-1407628059.png)


# 19、redis中只存20w的数据，如何保证redis中的数据都是热点数据？

redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略allkeys-lru，计算预估出20w数据所占空间，然后将redis限制为此数，同时设置redis回收策略为allkeys-lru回收最少使用.


# 22.Redis常用命令

SET key value NX PX 30000     键不存在时设置，并一起设置过期时间，PX是毫秒，EX是秒
set session_id "xyz" EX 3600  设置键 session_id，值为 "xyz"，过期时间为 3600 秒
HSET key field value          向键为 key 的哈希表中设置字段 field 的值为 value
HDEL key field                删除键为 key 的哈希表中的一个或多个字段
ZADD key score member         向有序集合 key 中添加一个成员，score 为 member 的分数
ZREM key member               移除有序集合 key 中的一个或多个成员。
INCR key                      将键 key 存储的数值增一
DECR key                      将键 key 存储的数值减一
LPUSH key value               将一个值插入到列表 key 的头部。
RPUSH key value               将一个值插入到列表 key 的尾部。


# 25.Redis集群方案

Redis集群中每个redis实例（可能一台机部署多个实例）会使用两个Tcp端口，一个用于给客户端（redis-cli或应用程序等）使用的端口 6379，另一个是用于集群中实例相互通信的内部总线端口，且第二个端口比第一个端口一定大10000。
集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521171725824-105309848.png)

Redis Cluster使用Gossip协议维护节点的元数据信息，这种协议是P2P模式的，主要指责就是信息交换。 Gossip协议工作原理就是节点彼此不断通信交换信息，一种去中心化思路的分布式协议，来确保网络中所有节点的数据一样。
redis官方集群方案集群超过800左右时,集群间通信占用大量带宽，集群吞吐量下降，性能下降严重。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521152242297-550427869.png)

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240521152534542-1420282275.png)

![](https://img-blog.csdnimg.cn/20210612182456981.png)

### 哨兵模式：解决了高可用问题，没解决分布式问题
- 主观下线：单个哨兵节点认为Redis节点下线，容易产生误判；
- 客观下线：当一个哨兵节点将某个节点标记位主观下线时，向其他哨兵节点发送通知。其他节点会根据检测结果判断，达到半数以上就会标记为客观下线。然后就触发主从切换。


# 26.Redis cluster集群为啥要求最少三个master节点，并且是奇数？

- 虽然Redis集群采用了无中心化设计思想， 但是cluster各节点之间需要互相通信确认对方是否存活，如果少于3个主节点，会产生网络分区问题，无法确认哪个节点异常。
- 奇数是为了解决投票选举时，得到多数派的支持。超过半数主节点(N/2 + 1)的投票才能当选。

# 27.谈谈Redis的哈希槽和一致性哈希

> 1.hash 算法（大量缓存重建）
> 2.一致性Hash算法，这种算法在适用代理集群方案中，主要在外部的代理模式 （Twemproxy）。 一致性Hash算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）。
> 3.官方Slot 哈希槽算法 ，这种算法就是 Cluster 的核心算法，每个键通过CRC16映射到这些槽，每个集群节点负责一定范围的槽。

在 Redis 3.0 之前，Redis 是没有集群方案的，在这个时期实现 Redis的分布式主要由客户端自行实现。一般的实现方式就是一致性Hash。
而 Redis 3.0 之后 ，Redis 实现了 Cluster 集群，也就采用了相对而言更简洁的 Slot 槽方式。

![](https://img2024.cnblogs.com/blog/1694759/202510/1694759-20251023155242222-1481705934.png)

**一致性哈希条件适用场景**：

> 纯Key-Value访问模式；无范围查询需求 ；无多机房容灾要求

**一致性哈希的不适用场景**：

> SQL范围查询（BETWEEN/ORDER BY）；多机房部署需求 ，需要拓扑感知；数据均衡性要求99.99%

# 30.分布式限流网关组件

**使用Redis+Lua来开发**,无论是Nginx外部网关还是Zuul内部网关，都可以使用Redis+Lua限流组件.理论上，接入层的限流有多个维度：
（1）用户维度限流：在某一时间段内只允许用户提交一次请求，比如可以采取客户端IP或者用户ID作为限流的key。
（2）商品维度的限流：对于同一个抢购商品，在某个时间段内只允许一定数量的请求进入，可以采取秒杀商品ID作为限流的key。

- nginx限流场景：
  + 用户维度的限流，可以在nginx上进行，因为使用nginx限流内存来存储用户id，比用redis 的key，来存储用户id，效率高。
- redis+lua分布式限流：
  + 商品维度的限流，可以在redis上进行，不需要大量的计算访问次数的key，另外，可以控制所有的接入层节点的访问秒杀请求的总量。

# 31.说一下 mongoDB

MongoDB是一种NoSQL数据库，它采用文档存储方式，支持动态查询和索引。下面是MongoDB的特性、优缺点和应用。

特性：

- **支持动态查询和索引** ：MongoDB使用BSON（Binary JSON）格式存储数据，支持动态查询和索引，可以快速查询和分析数据。
- **支持复制和故障转移** ：MongoDB支持复制和故障转移，可以保证数据的高可用性和可靠性。
- **支持分片** ：MongoDB支持自动分片，可以扩展到大规模数据集。
- **支持MapReduce** ：MongoDB支持MapReduce，可以进行复杂的数据分析和聚合。
- **支持全文搜索** ：MongoDB支持全文搜索，可以对文本进行高效的搜索和分析。

优点：

- **高性能** ：MongoDB采用内存映射和预分配空间等技术，可以实现高性能的读写操作。
- **易于扩展** ：MongoDB支持自动分片和复制，可以方便地进行扩展。
- **灵活性** ：MongoDB采用文档存储方式，可以方便地存储结构不固定的数据。
- **易于使用** ：MongoDB使用简单，支持多种编程语言和平台。

缺点：

- **不支持事务** ：MongoDB不支持多文档事务，只支持单文档事务。
- **存储空间占用较大** ：MongoDB采用BSON格式存储数据，存储空间占用较大。
- **不支持复杂查询** ：MongoDB不支持复杂查询，如多表连接等。

应用：

- **Web应用** ：MongoDB可以用于Web应用的数据存储和查询。
- **大数据分析** ：MongoDB支持MapReduce，可以用于大数据分析。
- **日志处理** ：MongoDB可以用于日志处理和分析。
- **移动应用** ：MongoDB可以用于移动应用的数据存储和查询。



