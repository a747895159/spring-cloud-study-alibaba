
# 1.简单的SpringIOC解决循环依赖的流程图
- 原理： 将注入的对象放入缓存中，将堆内存的物理地址暴露出去，循环引入对象直接获取地址即可。
- 如果是构造器方式注入，这不支持循环引入，直接报错。

![](https://img2020.cnblogs.com/blog/1694759/202108/1694759-20210821142210057-1202748366.png)



# 2.说说动态代理的实现方式和区别

动态代理是一种在运行时创建代理对象的方式，它可以在不修改原始类的情况下，为其添加额外的功能。在Java中，有两种常见的动态代理实现方式：基于接口的动态代理和基于类的动态代理。

1. **基于接口的动态代理** ：

* **实现方式** ：基于接口的动态代理是通过Java的`java.lang.reflect.Proxy`类实现的。该类提供了一个`newProxyInstance()`方法，通过传入目标类的接口、一个`InvocationHandler`对象和类加载器来创建代理对象。
* **实现原理** ：在运行时，当调用代理对象的方法时，实际上会被转发到`InvocationHandler`对象的`invoke()`方法中。在`invoke()`方法中，可以执行一些前置或后置操作，并最终调用目标对象的方法。
* **适用场景** ：基于接口的动态代理适用于目标对象实现了接口的情况。
* **基于类的动态代理** ：

* **实现方式** ：基于类的动态代理是通过使用第三方库（如CGLIB）来实现的。该库通过生成目标类的子类来创建代理对象。
* **实现原理** ：在运行时，当调用代理对象的方法时，实际上会被转发到子类中重写的方法中。在重写的方法中，可以执行一些前置或后置操作，并最终调用目标对象的方法。
* **适用场景** ：基于类的动态代理适用于目标对象没有实现接口的情况。

区别：

* 基于接口的动态代理要求目标对象实现接口，而基于类的动态代理可以代理任何类，无论是否实现接口。
* 基于接口的动态代理是通过Java标准库实现的，而基于类的动态代理需要使用第三方库。
* 基于接口的动态代理创建的代理对象是一个实现了目标接口的实例，而基于类的动态代理创建的代理对象是目标类的子类。
* 基于接口的动态代理执行效率相对较高，而基于类的动态代理执行效率较低。

总体而言，基于接口的动态代理更加灵活，并且是Java官方支持的方式；而基于类的动态代理在某些场景下更加方便，尤其是对于没有实现接口的类。


