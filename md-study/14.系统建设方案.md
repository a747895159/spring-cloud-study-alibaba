稳定性全系列
https://blog.csdn.net/manzhizhen/article/details/103642565

[TOC]

----

# 1. 高性能实践方案

- 分布式部署，通过负载均衡分担单机压力。
- 多层次缓存，包括静态数据使用 CDN、本地缓存、分布式缓存等，以及处理缓存场景中的热点 key、缓存穿透、缓存并发、数据一致性等问题。
- 数据库和索引优化，以及利用搜索引擎解决复杂查询问题。
- 考虑使用 NoSQL 数据库，如 HBase、TiDB 等，但团队需熟悉这些组件并具备强大的运维能力。
- 异步处理，将次要流程通过多线程、消息队列、甚至延时任务进行异步处理。
- 流量控制，考虑业务是否允许限流（如秒杀场景），包括前端限流、Nginx 接入层限流、服务端限流。
- 流量削峰填谷，通过消息队列接收流量。
- 并发处理，通过多线程将串行逻辑并行化。
- 预计算，如抢红包场景，可提前计算红包金额并缓存，发红包时直接使用。
- 缓存预热，通过异步任务提前将数据预热到本地缓存或分布式缓存中。
- 减少 IO 次数，如数据库和缓存的批量读写、RPC 的批量接口支持、或通过冗余数据减少 RPC 调用。
- 减少 IO 时的数据包大小，包括采用轻量级通信协议、合适的数据结构、去除接口中多余字段、减少缓存 key 大小、压缩缓存 value 等。
- 优化程序逻辑，如将高概率阻断执行流程的判断逻辑前置、For 循环计算逻辑优化，或采用更高效算法。
- 使用各种池化技术，如 HTTP 请求池、线程池（考虑 CPU 密集型或 IO 密集型设置核心参数）、数据库和 Redis 连接池等。
- JVM 优化，包括新生代和老年代的大小、GC 算法选择等，以减少 GC 频率和耗时。
- 锁策略选择，读多写少场景使用乐观锁，或考虑通过分段锁减少锁冲突。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240528145843749-1264242954.png)


# 2. 高可用实践方案

- 节点故障转移，Nginx 和服务治理框架支持故障节点切换到另一个节点。
- 非对等节点的故障转移，通过心跳检测并实施主备切换（如 Redis 哨兵模式或集群模式、MySQL 主从切换等）。
- 设置接口层的超时、重试策略和幂等设计。
- 降级处理，保证核心服务，牺牲非核心服务，必要时进行熔断；或核心链路出问题时，有备选链路。
- 流量控制，对超过系统处理能力的请求直接拒绝或返回错误码。
- 消息队列的可靠性保证，包括生产者端的重试机制、消息代理的持久化、消费者端的 ack 机制等。
- 灰度发布，支持按机器维度进行小流量部署，观察系统日志和业务指标，运行稳定后再推全量。
- 监控报警，包括基础 CPU、内存、磁盘、网络 监控，以及 Web 服务器、JVM、数据库、各类中间件监控和业务指标监控。
- 灾备演练，类似当前的“混沌工程”，对系统进行破坏性手段，观察局部故障是否会引起可用性问题。

高可用方案主要从冗余、取舍、系统运维三个方向考虑，同时需有配套的值班机制和故障处理流程，当出现线上问题时，可及时跟进处理。

![](https://img2024.cnblogs.com/blog/1694759/202406/1694759-20240625154701437-887935067.png)

![](https://img2024.cnblogs.com/blog/1694759/202406/1694759-20240625181715071-1865633960.png)


# 3. 按照二八法则来推算 1000w 用户的访问量,计算QPS

让我们回归最初的问题：1000W并发，需部署多少个节点？

假设我们没有历史数据可以参考，我们可以采用**二八定律** 来进行估算。

* 假设有 1000W 用户，每天访问网站的用户占比为 20%，那么每天大约有 200W 用户访问。
* 假设每个用户平均点击 50 次，那么总的页面浏览量 PV=1 亿。
* 一天有 24 小时，根据二八定律，每天大部分用户活跃的时间点集中在(24 /* 0.2) 约等于 5 个小时以内，而大部分用户指的是（1 亿点击 /* 80%）约等于 8000W（PV）， 意味着在 5 个小时以内，大概会有 8000W 点击进来，也就是每秒大约有 4500(8000W/5 小时)个请求。
* 4500 只是一个平均数值。在这 5 小时内，请求量并不一定均匀，可能会出现大量用户集中访问的情况（比如像淘宝这样的网站，日访问量高峰时间段集中在下午 14:00 和晚上 21:00，其中 21:00 是一天中访问量的最高峰）。通常情况下，访问量高峰时段的请求量是平均请求量的 3 到 4 倍（这是一个经验值），我们按照 4 倍来计算。那么在这 5 小时内，可能会出现每秒 18000 个请求的情况。因此，问题由原本的支撑 1000W 用户，变成了一个具体的问题，**就是服务器端需要能够支撑每秒 18000 个请求** （QPS=18000）

![](https://img-blog.csdnimg.cn/d840ccaaa2414b1eb180de5a81e26396.png)

![](https://img-blog.csdnimg.cn/ae3fa90dd82c40acb80cb93dbed42290.png)



# 4. 接口狂刷的主要防护措施：

- 交互式验证 :  	验证码验证；人机验证(先完成简单任务,在类似滑块或者识别图中的文字等)
- 安全参数校验：	请求参数中追加时间戳,随机字符串参与签名
- 使用HTTPS:		保证数据传输中不被篡改或窃取
- 用户访问认证	基于登录Token，防止非法请求
- 资源访问授权	基于访问资源权限进行精准控制
- 访问限流		防止过多请求导致系统崩溃
- IP封禁			将IP加入黑名单
- 日志监控与分析,进行统计预警 	使用开源工具Prometheus、Grafana、告警通知方式进行预警，及时运维防范。


# 6. 分布式系统设计两大思想：

- **中心化设计**： 领导和干活的 两种角色，"领导"负责分配协调任务。
    - 缺点："领导"出问题了,机器就崩溃了,存在单点问题;"领导存在"存在高性能问题;设计系统要考虑主备模型，提升可用性。
- **去中心化设计**：所有节点自由选择中心,任意节点宕机影响很小。
    - 缺点：去中心化设计里最难解决的一个问题是 “脑裂”问题 ，这种情况的发生概率很低，但影响很大。
      脑裂指一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。
      一般的设计思路是，当集群判断发生了脑裂问题时，规模较小的集群就“自杀”或者拒绝服务。




# 10. 常用链路追踪比较

- Skywalking方法级（展示的更详细），已加入Apache孵化器。方法中所有的调用都展示出来了，如数据库调用、redis调用，第三方网络调用，支持 **OpenTracing**（分布式系统追踪的协议规范）。 **代码无侵入**，开箱即用。使用字节码增强技术。UI界面国产开源，更适合国人眼球。支持TraceId查询，JVM监控。
- CAT 早起美团开发的链路追踪，代码需埋点，侵入较高。
- Zipkin：简单、轻量级，只能展示接口级。有一定的代码侵入性。
- Pinpoint **代码无侵入**收集的数据粒度非常细，UI功能强大，**但性能损耗大**，因其出现的时间较长，完成度也很高，应用的公司较多。

![](https://img2024.cnblogs.com/blog/1694759/202405/1694759-20240517153157239-1472669508.png)


# 12.XXL分布式任务调度

**单体系统** 中有许多实现 任务调度 的方式，如多线程方式、Timer 类、Spring Tasks 等
**分布式系统** 需要一个满足高可用、容错管理、负载均衡等功能的任务调度平台来实现任务调度。重复执行、宕机任务丢失、弹性扩容、任务调度监测。

xxl-job 由 调度中心 和 执行器 组成。客户端编写调度JOB，然后实例启动后根据`XxlJobSpringExecutor`相关配置，将实例地址注册到调度中心。

![](https://img2024.cnblogs.com/blog/1694759/202409/1694759-20240902150724165-1126143200.png)

![](https://img2024.cnblogs.com/blog/1694759/202409/1694759-20240902150835104-1406735434.png)

![](https://img2024.cnblogs.com/blog/1694759/202409/1694759-20240902163337832-623302811.png)


# 22.SOA架构与微服务架构

SOA 更加适合于庞大、复杂、异构的企业级系统，更多考虑的是兼容已有的系统，无法完全推倒重来或者进行大规模的优化和重构。一般使用企业服务总线ESB（服务定义、服务路由、消息转换、消息传递）进行通信，更加复杂和重量级。

微服务更加适合于快速、轻量级、基于 Web 的互联网系统，这类系统业务变化快，需要快速尝试、快速交付。使用Restful轻量级HTTP通信。

- 服务规模‌:SOA的服务通常比较大型，包含多个功能，各服务存在大量依赖，耦合较高，需要一起部署，更新和维护复杂。**微服务拆分较细，倾向于创建小型、轻量级的服务**，可以快速启动和停止，便于进行快速迭代和持续交付‌。

- ‌数据管理‌:SOA通常采用统一的数据存储进行全局的数据管理和数据共享。微服务中，每个服务都有自己的独立数据存储，以实现服务之间的松耦合‌。



# 22.DDD领域驱动设计

领域驱动设计（Domain-Driven Design，简称DDD）是一种软件开发方法，它强调将业务领域的知识和逻辑集中在领域模型中。 根据限界上下文边界构建领域模型，将领域模型作为微服务设计的输入，进而完成微服务拆分与设计。
用DDD方法设计出来的微服务，业务和应用边界非常清晰，符合"高内聚，低耦合"的设计原则，提高软件的可理解性、可维护性和可扩展性。

## 主要组成部分

**领域模型**：是一种反映领域中实体、值对象、聚合根、仓储等概念的抽象模型。
**战略设计**：包括限界上下文、子域划分、通用语言等，用于确定系统的边界和业务范围。
**战术设计**：涉及实体、值对象、聚合、聚合根、领域服务、仓储等具体设计元素，用于构建领域模型的具体实现。

## 分层架构

**展现层**: 负责向用户显示信息和解释用户命令，完成前端界面逻辑。
**应用层**: 尽量简单，负责协调领域层中的领域对象，组成具体应用场景。
**领域层**: 软件的核心逻辑所在,负责表达业务概念、业务状态信息以及业务规则。
**基础设施层**: 提供通用的技术能力，如消息传递、持久化机制。

**限界上下文**指的是一个具有明确边界的领域模型，用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。

## 微服务拆分原理
**从上往下看业务流程，从下往上看实体依赖**，
先从上到下做业务流程梳理，将流程归类聚合；然后从不同的业务领域聚合中找出交互所需主要实体。
再从下到上看根据**实体之间的依赖程度、业务流程归类**，把不同的**实体和动作**拆分成多个模块，划分出最终的模块。

![](https://img2024.cnblogs.com/blog/1694759/202409/1694759-20240905103639460-689325098.png)


# 30. 其他系统设计图

![](https://img2024.cnblogs.com/blog/1694759/202404/1694759-20240429101941894-1113414868.png)

