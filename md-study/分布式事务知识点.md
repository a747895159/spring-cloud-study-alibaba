
https://blog.csdn.net/crazymakercircle/article/details/109459593?spm=1001.2014.3001.5501

![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210910204311142-294569943.png)

# 1.分布式事务名词解释
- 1.XA模式：
    X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。
    全局的事务管理器与局部的资源管理器之间的接口。 XA规范 的目的是允许的多个资源（如数据库，应用服务器，消息队列等）在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。
    XA 规范 使用两阶段提交（2PC，Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务。
    
    - 在X/Open **DTP(Distributed Transaction Process)**模型里面，有三个角色：
        AP: Application，应用程序。也就是业务层。哪些操作属于一个事务，就是AP定义的。
        TM: Transaction Manager，事务管理器。接收AP的事务请求，对全局事务进行管理，管理事务分支状态，协调RM的处理，通知RM哪些操作属于哪些全局事务以及事务分支等等。这个也是整个事务调度模型的核心部分。
        RM：Resource Manager，资源管理器。一般是数据库，也可以是其他的资源管理器，如消息队列(如JMS数据源)，文件系统等。

    缺陷: 数据锁定、协议阻塞、性能损耗高
        
   
- 2.2PC：
    PreCommit 请求阶段：分布式事务协调者（Coordinator）首先会分别向参与者发送事务预处理请求;
    DoCommit 提交阶段：分布式事务协调者（Coordinator）首先会分别向参与者发送事务提交(回滚)请求;
    
    缺点：
        **性能问题**：各个操作数据库的节点此时都占用着数据库资源,过程会比较漫长，对性能影响比较大。
        **协调者单点故障问题**：事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉,从而导致参与者节点始终处于事务无法完成的中间状态
        **丢失消息导致的数据不一致问题**：在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题

- 3.3PC:
    CanCommit 可提交阶段: 检查自身节点应用健康性，有没有能力处理事务
    PreCommit 请求阶段
    DoCommit 提交阶段
    
    ![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210930142135550-976008426.png)

    
    缺点：
        3PC对于协调者（Coordinator）和参与者（Partcipant）都设置了超时时间，而2PC只有协调者才拥有超时机制,主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围.
        相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的。相对缓解了2PC中的前两个问题,但是3PC依然没有完全解决数据不一致的问题。
        
    
- 4.补偿事务TCC
    TCC与2PC、3PC都是分布式事务实现的一种解决方案。分为3个阶段：Try阶段(主要是对业务系统做检测及资源预留)、Confirm阶段(确认执行业务操作)、Cancel阶段(取消执行业务操作).
    
    ![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210930143542113-1454332310.png)
    
    优点：
       TCC事务流程与2PC阶段类似，不过2PC是放在跨库的DB层面，而TCC是一个应用层面的2PC，通过业务逻辑来实现。应用自定义数据库操作粒度，**降低锁冲突，提供吞吐量**。 
    缺点：
        对应用的侵入性非常强，业务每个逻辑都要进行try、confirm、cancel三个操作。为了满足一致性的要求，confirm和cancel接口还必须实现幂等。

- 5.Seata AT模式
    是个增强型2PC模式：一阶段业务数据和回滚日志在同一个本地事务中提交，释放本地锁与链接资源。二阶段：提交异步化快速完成，或回滚一阶段日志反向补偿。
        

- 6.LCN(2PC)


- 7.SAGA长事务模型
    将一个分布式事务拆分成多个本地食物，每个本地事务都有相应的执行和补偿模块。任何一个本地事务出错，都可以通过调用补偿方法恢复，达到最终一致性。
    牺牲了一定的隔离性和一致性，提高了长事务的可用性    



# 2.事务简介    
- 事务特性: ACID(原子性、一致性、隔离性、持久性)
    - 通过数据库锁的机制，保障事务的隔离性;
    - 通过Redo Log(重做日志),保障事务的持久性;
    - 通过Undo Log(撤销日志),保障事务的原子性和一致性;
- 事务隔离级别：RU读未提交、RC读已提交、RR可重复读、SERIALIZABLE(可串行化)。MySql默认为 RR可重复读。
  
- CAP定理：一致性、可用性、分区容错性。分布式事务中, P 分区容错性必须保留。只能在一定程度 使用CP或者AP 模式。
- BASE定理：
    - BA 基本可用：分布式系统有不可预知的故障,允许损失部分可用性，但系统还是可用的。
    - S 软状态：允许系统数据存在中间状态
    - E 最终一致性：该方案是AP方案的延伸，对于C我们采用最终一致性的处理。
    
- 分布式事务分类：
    - 刚性事务：强一致性，原生支持回滚/隔离性，低并发，适合短事务。
              XA 协议（2PC、JTA、JTS）、3PC都是刚性事务，但由于同步阻塞，处理效率低，不适合大型网站分布式场景。
        
    - 柔性事务：不要求强一致性，而是要求最终一致性，允许有中间状态，也就是Base理论。   
              分为补偿型、异步确保型、最大努力通知型。主要有 TCC、Saga(状态机模式、Aop模式)、本地事务消息、MQ通知消息事务
    
    ![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210930143000830-2069655612.png)
    


# 3.Saga 之 MQ半消息模式

- 就是在消息上加了一个状态。当发送者第一次将消息放入MQ后，该消息为待确认状态。该状态下，该消息是不能被消费者消费的。发送者必须二次和MQ进行交互，将消息从待确认状态变更为确认状态后，消息才能被消费者消费。待确认状态的消息，就称之为半消息。
- 半消息事务逻辑：
    向MQ发送半消息。
    向DB插入数据。
    向MQ发送确认消息。
- 假设，第2步失败了，那么，MQ中的消息就会一直是半消息状态，也就不会被消费者消费。
  那么，半消息就一直存在于MQ中吗？或者是说如果第3步失败了呢？
  为了解决上面的问题，MQ引入了一个扫描的机制。即MQ会每隔一段时间，对所有的半消息进行扫描，并就扫描到的存在时间过长的半消息，向发送者进行询问，询问如果得到确认回复，则将消息改为确认状态，如得到失败回复，则将消息删除。
  如上，半消息机制的一个问题是：**要求业务方提供查询消息状态接口，对业务方依然有较大的侵入性**。

# 4.Seata 介绍与 AT模式

+ Seata 是一款开源的分布式事务解决方案,提供了 AT、TCC、SAGA 和 XA 事务模式。
+ Seata 分三大模块 :
    TC ：事务协调者。负责我们的事务ID的生成，事务注册、提交、回滚等。
    TM：事务发起者。定义事务的边界，负责告知 TC，分布式事务的开始，提交，回滚。
    RM：资源管理者。管理每个分支事务的资源，每一个 RM 都会作为一个分支事务注册在 TC。

+ 增强型2PC模式,增强型XA模型。TM和RM都作为SDK的一部分和业务服务在一起，我们可以认为是Client。TC是一个独立的服务，通过服务的注册、发现将自己暴露给Client们。
    每个服务的数据库中维护了一张 undo_log 表,记录了对 业务表 进行操作前后记录的镜像数据.
    TM 开启分布式事务（TM 向 TC 注册全局事务记录）；按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）；
    TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交/回滚分布式事务）；
    TC 汇总事务信息，决定分布式事务是提交还是回滚；
    TC 通知所有 RM 提交/回滚 资源，事务二阶段结束；

+ 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
+ 二阶段：提交异步化，非常快速地完成。或回滚通过一阶段的回滚日志进行反向补偿。
    AT 模式和 XA 最大的不同点，在 XA 事务的两阶段提交中，被锁定的记录直到第二阶段结束才会被释放。所以 AT 模式减少了锁记录的时间，从而提高了分布式事务的处理效率。AT 模式之所以能够实现第一阶段完成就释放被锁定的记录，是因为 Seata 在每个服务的数据库中维护了一张 undo_log 表，其中记录了对 业务表 进行操作前后记录的镜像数据，即便第二阶段发生异常，只需回放每个服务的 undo_log 中的相应记录即可实现全局回滚。

  

![](https://img2020.cnblogs.com/blog/1694759/202110/1694759-20211009150141957-345544643.png)


    第一阶段提交后，Seata会接收到所有分支事务的提交状态，然后决定提交全局事务还是回滚事务。
    1.当所有分支全部提交成功后，第二阶段就会删除相应分支事务的undo_log记录，即使删除失败，也不会对分布式事务产生实质影响。
    2.若任一分支事务本地提交失败，则Seata进行全局回滚，根据各分支事务第一阶段产生的undo_log记录进行补偿。先进行数据校验，若afterImage中的记录与当前表记录不一致，说明从第一阶段完成到此刻期间，有别的事务修改了记录，导致无法回滚，向Seata反馈回滚失败。若afterImage中的记录与当前表记录一致，说明没有别的事务修改记录，根据beforeImage与afterImage计算出补偿SQL进行回滚，然后删除undo_log。向Seate反馈回滚成功。

- Seata的数据隔离：

    - **写隔离**

        ```
        分支事务1-开始
        |
        获取 本地锁
        |
        获取 全局锁			分支事务2-开始
        |					|
        提交 本地事务			获取 本地锁
        |					|
        释放 本地锁			获取 全局锁	
        |					|
        释放 全局锁			提交本地事务
        					|
        					释放 本地锁
        					|
        					释放 全局锁
        					
        ```

        - 如上所示，一个分布式事务的锁获取流程是这样的
          1）先获取到本地锁，这样你已经可以修改本地数据了，只是还不能本地事务提交
          2）而后，能否提交就是看能否获得全局锁
          3）获得了全局锁，意味着可以修改了，那么提交本地事务，释放本地锁
          4）当分布式事务提交，释放全局锁。这样就可以让其它事务获取全局锁，并提交它们对本地数据的修改了。

        - 可以看到，这里有两个关键点
          1）本地锁获取之前，不会去争抢全局锁
          2）全局锁获取之前，不会提交本地锁

          这就意味着，数据的修改将被互斥开来。也就不会造成写入脏数据。全局锁可以让分布式修改中的写数据隔离。

        - 写隔离的原则：
          一阶段本地事务提交前，需要确保先拿到 全局锁 。
          拿不到 全局锁 ，不能提交本地事务。
          拿 全局锁 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

    - 读隔离

        - 在数据库本地事务隔离级别 读已提交（Read Committed） 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 读未提交（Read Uncommitted） 。
            如果应用在特定场景下，必需要求全局的 读已提交 ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。

            SELECT FOR UPDATE 语句的执行会申请 全局锁 ，如果 全局锁 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 全局锁 拿到，即读取的相关数据是 已提交 的，才返回。
            出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。



# 5.Seata TCC模式  
- Seata TCC与 AT事务一样都是两阶段事务主要区别：

  - TCC对业务代码入侵严重，每个阶段的数据操作都要进行编码实现，事务框架无法自行处理，对每个业务都要增加中间处理，复杂性太高。

  - TCC 性能更高，无需全局加锁，允许多个事务同时操作

  - AT模式要基于本地ACID事务的关系型数据库、TCC不依赖于底层数据源的事务支持。

    

    ![](https://img2020.cnblogs.com/blog/1694759/202110/1694759-20211009173328642-137991189.png)
    	

- 举例：比如下单支付100元：
		- 第一阶段 try阶段，调用自定义的prepare逻辑：先冻结账户100元,做其他业务
		- 第二阶段 confirm阶段，都成功调用自定义的commit逻辑：扣除冻结进行，
		- 第二阶段 cancel，调用者自定义的回滚逻辑：解冻余额，账户金额回加上去
	
- Seata AT模式和Seata TCC是在生产中最常用。
    强一致性模型，Seata AT 强一致方案 模式用于强一致主要用于核心模块，例如交易/订单等。
    弱一致性模型。Seata TCC 弱一致方案一般用于边缘模块例如库存，通过TC的协调，保证最终一致性，也可以业务解耦。

# 6.Seata Sage模式  
将一个分布式事务拆分成多个本地食物，每个本地事务都有相应的执行和补偿模块。任何一个本地事务出错，都可以通过调用补偿方法恢复，达到最终一致性。
	牺牲了一定的隔离性和一致性，提高了长事务的可用性


# 7.Seate XA模式
编程模型上 XA模式与AT模式完全一致，只需要修改下数据源的代理即可实现XA与AT模式的切换。

```
    @Bean("dataSource")
    public DataSource dataSource(DruidDataSource druidDataSource) {
        // DataSourceProxy for AT mode
        // return new DataSourceProxy(druidDataSource);

        // DataSourceProxyXA for XA mode
        return new DataSourceProxyXA(druidDataSource);
    }

```

# 8.如何解决分布式事务问题？
- 1.强一致性场景，可以使用Seata AT模式来保证强一致性。
	- 比如电商交易：下单、扣库存与优惠券业务。
- 2.弱一致性场景，可以使用Seata TCC模式，当然也可以使用异步确保型事务(MQ消息事务、本地消息表事务)。

![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210930145548160-2104134354.png)