

# 1.Elasticsearch与 Lucene 的区别？
- Lucene是一个java 开发的全文检索引擎工具包,提供完整的查询引擎与索引引擎。solr和ES都是基于该工具包的一些封装。
- ES是基于Lucene的二次开发，ES每个分片都是一个分离的Lucene实例。ES在Lucene基础上提供一个分布式的、基于JSON的WEB服务。


# 2.ES 在数据量很大的情况下（数十亿级别）如何提高查询效率啊？
- ES的搜索引擎依赖底层的Lucene的文件缓存filesystem cache,如果给Lucene足够的内存，可以将所有的idx segment file 索引数据文件容纳在内存之中，性能非常高。
- 当数据量很大时，几十亿条时，懵逼的发现第一次搜索5-10s,后面查询就快了几百毫秒。就是Lucene首次缓存了文件索引。
- 假如ES数据量1T,ES 3台，每台32G内存，Lucene内存32G。1T的数据量是每台320G左右，而每台Lucene内存才32G,也就是1/10的数据才可以放内存。
  然后执行查询操作大部分都是走磁盘，性能肯定差。要让ES性能好，最好是将数据量都可以放到Lucene内存中。
  假如有一行数据30多个字段,只有是几个字段参与搜索，80%的字段不参与搜索的。结果是占据Lucene上的filesystem cache的空间，缓存的有效数据越少。
  可以采用es+hbase架构，将参与查询的索引放到ES中，从ES查询到id,然后id到HBASE查询全部数据。
  

# 3.假如一台机器内存64G,ES内存多少合适？
- ES是基于 Lucene二次开发的，Lucene的设计是把底层OS的数据缓存到内存中。Lucene的性能取决于和OS交互,如果内存太小，全文索引性能太差。
- 标准情况下50%的内容给ES，50%的内存给Lucene,用于文件缓存。
- ES内存不要超过32G,主要原因是JVM在内存小于32G的时候会采用**内存对象指针压缩技术**：
    - 在java中，所有的对象都分配在堆上,然后用指针引用它。这些指针的大小通常是CPU的字长大小,取决于处理器,一般32位或64位。
        但是64位的指针意味着更大的浪费,浪费内存无所谓，主要是更大的指针在主存与告诉缓冲器之间数据移动的时候,会占用更多的资源与带宽。
    - Java使用内存指针压缩技术来解决以上问题，它的指针不再是内存的精确位置，而是表示偏移量。也就意味着32位指针可以引用40亿个对象。
    - 当内存越过申请的边界 30-32G时，对象指针边长，会使用更多的CPU内存带宽，当内存40-50G的时候才相当于使用压缩技术时候的32G内存。
    - 如果你有台大机器内存,你可以多部署几个节点，仍然使用50%原则,32G内存给ES 32G内存给Lucene.


# 4.ES 使用存在的坑点
- ES 的每个分片（shard）都是lucene的一个index，而lucene的一个index只能存储20亿个文档，单个分片的大小在10G-50G之间。
- string类型的字段设置了双字段，既是text，又是keyword，导致存储容量增大了一倍。部分场景根据keywork查询即可，去掉text字段，节约空间。
- 增加**routing key**,可以将请求分发到具体的shard，减少大量不必要的请求。
- 过多依赖ES聚合结果，ES聚合结果不是很精确的。
- 分桶多字段聚合查询容易引起OOM。ES对于这种嵌套聚合默认使用了深度优先规则。
- ES中更新操作存在近1s的延迟，主要是写数据是定时写入,refresh_interval默认为1s。































