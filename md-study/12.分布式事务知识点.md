https://blog.csdn.net/crazymakercircle/article/details/109459593?spm=1001.2014.3001.5501

[TOC]


![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210910204311142-294569943.png)


# 1.分布式事务理论

- 事务特性: ACID(原子性、一致性、隔离性、持久性)

    - 通过数据库锁的机制，保障事务的隔离性;
    - 通过Redo Log(重做日志),保障事务的持久性;
    - 通过Undo Log(撤销日志),保障事务的原子性和一致性;

- 事务隔离级别：RU读未提交、RC读已提交、RR可重复读、SERIALIZABLE(可串行化)。MySql默认为 RR可重复读。

- CAP定理：一致性、可用性、分区容错性。分布式事务中, P 分区容错性必须保留。只能在一定程度 使用CP或者AP 模式。

- BASE定理：

    - BA 基本可用：分布式系统有不可预知的故障,允许损失部分可用性，但系统还是可用的。
    - S 软状态：允许系统数据存在中间状态
    - E 最终一致性：该方案是AP方案的延伸，对于C我们采用最终一致性的处理。

- 分布式事务分类：

    - 刚性事务：强一致性，原生支持回滚/隔离性，低并发，适合短事务。
      XA 协议（2PC、JTA、JTS）、3PC都是刚性事务，但由于同步阻塞，处理效率低，不适合大型网站分布式场景。

    - 柔性事务：不要求强一致性，而是要求最终一致性，允许有中间状态，也就是Base理论。

      > 分为补偿型、异步确保型、最大努力通知型。
      > 主要有 TCC、Saga(状态机模式、Aop模式)、本地事务消息、MQ通知消息事务


# 2.事务名词解释

## XA模式：

X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。有三个角色：

- AP: Application，应用程序。也就是业务层。哪些操作属于一个事务，就是AP定义的。
- TM: Transaction Manager，事务管理器。接收AP的事务请求，对全局事务进行管理，管理事务分支状态，协调RM的处理，通知RM哪些操作属于哪些全局事务以及事务分支等等。这个也是整个事务调度模型的核心部分。
- RM：Resource Manager，资源管理器。一般是数据库，也可以是其他的资源管理器，如消息队列(如JMS数据源)，文件系统等。

缺陷: 数据锁定、协议阻塞、性能损耗高

![](https://img2024.cnblogs.com/blog/1694759/202407/1694759-20240726151947834-271882580.png)


## 2PC：

第一阶段PreCommit 请求阶段：分布式事务协调者 会分别向参与者发送事务预处理请求;
第二阶段DoCommit 提交阶段：分布式事务协调者 会分别向参与者发送事务提交(回滚)请求;

![](https://img2024.cnblogs.com/blog/1694759/202407/1694759-20240726152032342-74158872.png)


缺点：

- **性能问题**：各个操作数据库的节点此时都占用着数据库资源,过程会比较漫长，对性能影响比较大。
- **协调者单点故障问题**：事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉,从而导致参与者节点始终处于事务无法完成的中间状态
- **丢失消息导致的数据不一致问题**：在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间数据的不一致问题

## 3PC:

比2PC多了CanCommit 可提交阶段: 检查自身节点应用健康性，有没有能力处理事务

![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210930142135550-976008426.png)

缺点：
3PC对于协调者和参与者都设置了超时时间，而2PC只有协调者才拥有超时机制,主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit/rollback从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围.
相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的。
**3PC多了可提交阶段，对于协调者和参与者都设置了超时时间，相对缓解了性能问题（减少阻塞：参与者无法及时收到来自协调者的信息之后会默认执行commit）与协调者单点故障问题。依然没有解决丢失消息导致数据不一致的问题; 同时也存在性能问题**

## 补偿事务TCC

TCC与2PC、3PC都是分布式事务实现的一种解决方案。分为3个阶段：Try阶段(主要是对业务系统做检测及资源预留)、Confirm阶段(确认执行业务操作)、Cancel阶段(取消执行业务操作).

![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210930143542113-1454332310.png)

优点：
TCC事务流程与2PC阶段类似，不过2PC是放在跨库的DB层面，而TCC是一个应用层面的2PC，通过业务逻辑来实现。应用自定义数据库操作粒度，**降低锁冲突，提供吞吐量**。
缺点：
对应用的侵入性非常强，业务每个逻辑都要进行try、confirm、cancel三个操作。为了满足一致性的要求，confirm和cancel接口还必须实现幂等。

## Seata AT模式

增强型2PC模式：一阶段业务数据和回滚日志在同一个本地事务中提交，释放本地锁与链接资源。二阶段：提交异步化快速完成，或回滚一阶段日志反向补偿。

## Saga长事务

将一个分布式事务拆分成多个本地食物，每个本地事务都有相应的执行和补偿模块。任何一个本地事务出错，都可以通过调用补偿方法恢复，达到最终一致性。
牺牲了一定的隔离性和一致性，提高了长事务的可用性


## 本地消息表(MQ事务消息)

- 1.本地消息表的核心思想是将分布式事务拆分成本地事务进行处理。然后通过定时任务轮询的方式去查询消息表，将消息推送到MQ(或者接口幂等调用)。
- 2.使用MQ事务消息，省去对本地消息表的操作和轮询发送MQ(或者接口幂等调用)的操作。

## 最大努力通知

![](https://img2024.cnblogs.com/blog/1694759/202407/1694759-20240726152535817-86828120.png)



# 3.Seata 介绍

+ Seata 是一款开源的分布式事务解决方案,提供了 XA 、 AT、TCC、SAGA 事务模式。


![](https://img2024.cnblogs.com/blog/1694759/202408/1694759-20240821154824049-2006725575.png)


+ Seata 分三大模块 :
  **TC ：事务协调者** 一个独立的Server服务，负责事务ID的生成，事务注册、提交、回滚等。
  **TM：事务管理器** 是Client端，由业务系统集成，分布式事务的开始，提交，回滚。
  **RM：资源管理者** 管理每个分支事务的资源，每一个 RM 都会作为一个分支事务注册在 TC。

# 4.Seate之XA模式

XA/AT模式是增强型2PC模式，编程模型上XA完全一致，只需要修改下数据源的代理即可实现XA与AT模式的切换。基于本地ACID事务的关系型数据库。
TM和RM都作为SDK的一部分和业务服务在一起，我们可以认为是Client。
TC是一个独立的服务，通过服务的注册、发现将自己暴露给Client们。

### 事务流程

- TM 开启分布式事务（TM 向 TC 注册全局事务记录）；按业务场景，编排数据库,RM 向 TC 汇报资源准备状态；
- TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交/回滚分布式事务）；
- TC 汇总事务信息，决定分布式事务是提交/回滚；通知所有 RM 提交/回滚 资源,二阶段结束；

```
    @Bean("dataSource")
    public DataSource dataSource(DruidDataSource druidDataSource) {
        // DataSourceProxy for AT mode
        // return new DataSourceProxy(druidDataSource);

        // DataSourceProxyXA for XA mode
        return new DataSourceProxyXA(druidDataSource);
    }

```


# 5.Seata之AT模式

**每个服务的数据库中维护了一张 undo_log 表,记录了对 业务表 进行操作前后记录的镜像数据.**

+ 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
+ 二阶段：提交异步化，非常快速地完成。或回滚通过一阶段的回滚日志进行反向补偿。

> - 当所有分支全部提交成功后，第二阶段就会删除相应分支事务的undo_log记录，即使删除失败也不会产生问题。
> - 若任一分支事务本地提交失败，Seata进行全局回滚，根据各分支事务第一阶段产生的undo_log记录进行补偿，先进行数据校验。
> - 若afterImage中的记录与当前表记录不一致，说明从第一阶段完成到此刻期间，有别的事务修改了记录，导致无法回滚，向Seata反馈回滚失败。
> - 若afterImage中的记录与当前表记录一致，说明没有别的事务修改记录，根据beforeImage与afterImage计算出补偿SQL进行回滚，然后删除undo_log。向Seata反馈回滚成功。

![](https://img2024.cnblogs.com/blog/1694759/202408/1694759-20240821113210136-1807012863.png)

![](https://img2024.cnblogs.com/blog/1694759/202408/1694759-20240821113104254-864025659.png)



### AT与XA 最大的不同点:

- 在 XA 事务的两阶段提交中，被锁定的记录直到第二阶段结束才会被释放。
- AT 模式通过undo_log表记录前后的镜像数据，在第一阶段释放资源，减少了锁记录的时间，从而提高了分布式事务的处理效率。即便第二阶段发生异常，只需回放每个服务的 undo_log 中的相应记录即可实现全局回滚。

![](https://img2020.cnblogs.com/blog/1694759/202110/1694759-20211009150141957-345544643.png)

### AT数据隔离：

```
    分支事务1-开始
    |
    获取 本地锁          分支事务2-开始
    |                   |
    获取 全局锁			获取 本地锁
    |					|
    提交 本地事务			|
    |					|
    释放 本地锁			|(获取本地锁成功)	
    |                   |						
    释放 全局锁           获取 全局锁
                        |
                        提交本地事务
                        |
                        获取 全局锁
                        |
                        提交本地事务
```

全局锁：Seata会将需要加锁的数据行（或主键值）与这个XID关联起来，并注册到事务协调器（TC）中。这样，就可以通过全局锁来确保在全局事务提交之前，其他事务无法对这些数据进行修改，从而避免脏写等问题。

- **写隔离**

    - 如上所示，一个分布式事务的锁获取流程是这样的
      1）先获取到本地锁，这样你已经可以修改本地数据了，只是还不能本地事务提交
      2）而后，能否提交就是看能否获得全局锁
      3）获得了全局锁，意味着可以修改了，那么提交本地事务，释放本地锁
      4）当分布式事务提交，释放全局锁。这样就可以让其它事务获取全局锁，并提交它们对本地数据的修改了。

    - 可以看到，这里有两个关键点
      1）本地锁获取之前，不会去争抢全局锁
      2）全局锁获取之前，不会提交本地锁
      这就意味着，数据的修改将被互斥开来。也就不会造成写入脏数据。全局锁可以让分布式修改中的写数据隔离。

    - 写隔离的原则：
      一阶段本地事务提交前，需要确保先拿到 全局锁 。
      拿不到 全局锁 ，不能提交本地事务。
      拿 全局锁 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

- **读隔离**

    - 在数据库本地事务隔离级别 读已提交（Read Committed） 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 读未提交（Read Uncommitted） 。

      > - 如果应用在特定场景下，必需要求全局的 读已提交 ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。
      > - 加@GlobalLock注解只会在执行过程中查询全局锁是否存在，不会去开启全局事务。@GlobalTransactional注解 开启全局事务是一个比较重的操作，需要向 TC 发起开启全局事务等 RPC 过程
      > - SELECT FOR UPDATE 语句的执行会申请 全局锁 ，如果 全局锁 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 全局锁 拿到，即读取的相关数据是 已提交 的，才返回。
      > - 出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。


### 优缺点：

- 优点：对业务代码侵入性小、自动补偿事务、Seata框架自动完成
- 缺点：依赖数据库支持与兼容性限制

### 全局锁实现步骤

Seata AT模式通过一种名为“全局事务标识”（Global Transaction ID, XID）与“回滚日志”的机制来间接实现资源的锁定和并发控制。全局锁实现步骤：

- 1.全局事务开启：当一个全局事务开始时，TM（Transaction Manager）会向TC（Transaction Coordinator）注册一个全局事务，并获得一个全局唯一的事务ID（XID）。

- 2.本地事务执行：在每个需要参与全局事务的RM（Resource Manager，即数据库）上，Seata通过代理的方式拦截SQL操作。在执行业务SQL之前，Seata会在同一个本地事务中先执行两件事：

    - 前置操作：插入“回滚日志”（Undo Log），记录事务前的数据状态，用于将来可能的回滚操作。
    - 业务操作：执行实际的业务SQL，修改数据。

- 3.锁标记与数据版本：在插入回滚日志的同时，会将XID与数据行关联起来，这种关联可以视为一种逻辑锁，表示这些数据正在被某个全局事务处理中。虽然没有物理锁住数据行，但实际上通过XID的关联实现了对数据的逻辑锁定。

- 4.提交与解锁：

    - 一阶段提交：本地事务提交，释放本地资源锁，但数据变更依赖于XID的关联，处于待提交状态。
    - 二阶段提交：TC根据一阶段的结果决定是否提交全局事务。如果所有分支事务都成功，则TC通知各RM提交，否则，根据回滚日志进行回滚，恢复数据到事务前状态。

- 5.锁住的内容：全局锁实际上锁住的是数据行与XID的关联关系，而不是直接锁住数据行本身。这意味着，当一个事务操作某行数据时，通过XID标记了该数据的“占有状态”，其他事务看到这个标记就会知道该数据正处于某个全局事务的处理中，从而避免并发修改。

通过上述机制，Seata AT模式实现了全局锁的效果，既保证了数据的一致性，又尽量减少了传统锁机制带来的性能开销。这种方式尤其适合分布式系统中的并发控制，因为它允许更多的并发读取操作，而不会像传统锁那样造成过多的阻塞。


# 6.Seata TCC模式

TCC 对**业务代码入侵严重**，每个阶段的数据操作都要进行编码实现，事务框架无法自行处理，对每个业务都要增加中间处理，复杂性太高。**TCC 性能更高，无需全局加锁，允许多个事务同时操作，不依赖于底层数据源的事务支持**

![](https://img2020.cnblogs.com/blog/1694759/202110/1694759-20211009173328642-137991189.png)

**第一阶段** ：Try（尝试），主要是对业务系统做检测及资源预留 **(加锁，锁住资源)**
**第二阶段** ：本阶段根据第一阶段的结果，决定是执行**confirm** 还是**cancel**
**Confirm** （确认）：执行真正的业务（执行业务，释放锁）
**Cancle** （取消）：是预留资源的取消（出问题，释放锁）


![](https://img2024.cnblogs.com/blog/1694759/202408/1694759-20240821113240051-2033905135.png)

![](https://img2024.cnblogs.com/blog/1694759/202408/1694759-20240821153545348-288368375.png)


- 举例：比如下单支付100元：
    - 第一阶段 try阶段，调用自定义的prepare逻辑：先冻结账户100元,做其他业务
    - 第二阶段 confirm阶段，都成功调用自定义的commit逻辑：扣除冻结进行，
    - 第二阶段 cancel，调用者自定义的回滚逻辑：解冻余额，账户金额回加上去
- Seata AT模式和Seata TCC是在生产中最常用。
    - Seata AT 强一致模式，模式用于强一致主要用于核心模块，例如交易/订单等。
    - Seata TCC 弱一致模式，一般用于边缘模块例如库存，通过TC的协调，保证最终一致性，也可以业务解耦。

## 常见异常问题处理

维护一个**事务状态表** ，每个事务的执行阶段全部记录下来。

- **幂等**：如果confirm或者cancel方法执行失败，要一直重试直到成功。
    - 在执行confirm或者cancel之前根据事务状态表查询当前全局事务是否已经执行过confirm或者cancel方法。
- **空回滚**：在未调用try方法或try方法未执行成功的情况下，就执行了**cancel**方法进行了回滚
    - 在执行cancel之前才能根据事务状态表查询当前全局事务是否已经执行成功try方法
- **悬挂**：可能会出现因网络拥堵而导致的超时，会出现cancel接口先调用后，try接口再请求过来。
    - 在执行try方法之前，根据事务状态表查询当前全局事务是否已经执行过cancel方法

# 7.Seata Saga模式

- 编排式，是基于状态机引擎实现的，将一个分布式事务拆分成多个本地食物，每个本地事务都有相应的**执行和补偿方法(重试与回滚)**。任何一个本地事务出错，都可以通过调用补偿方法，达到最终一致性。
- Saga 模式一阶段就会提交本地事务，无锁、长流程情况下可以保证性能。
- 牺牲了一定的隔离性和一致性，提高了长事务的可用性。
- Saga 之 MQ半消息模式 (RocketMQ事务消息) **要求业务方提供查询消息状态接口，对业务方依然有较大的侵入性**。


# 8.如何解决分布式事务问题？

- 1.强一致性场景，可以使用Seata AT模式来保证强一致性。
    - 比如电商交易：下单、扣库存与优惠券业务。
- 2.弱一致性场景，可以使用Seata TCC模式、异步最终一致方案确保型事务(MQ事务消息、本地消息表事务)。

![](https://img2020.cnblogs.com/blog/1694759/202109/1694759-20210930145548160-2104134354.png)